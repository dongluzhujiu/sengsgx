diff --git a/.gitignore b/.gitignore
index e987bac..d66ad09 100644
--- a/.gitignore
+++ b/.gitignore
@@ -64,6 +64,8 @@ sgxlkl-wolfssl-ssl-server
 wolfssl-ssl-server-mutual
 wolfssl-client-mutual
 
+ssl_client
+
 # Graphene-SGX
 *.sig
 *.token
diff --git a/Makefile b/Makefile
index b4d3e3d..a053128 100644
--- a/Makefile
+++ b/Makefile
@@ -1,9 +1,9 @@
 # Makefile to build non-SGX-SDK-based RA-TLS client and server
 # programs.
 
-CFLAGS=-std=gnu99 -I. -I/opt/intel/sgxsdk/include -Ideps/local/include -fPIC
+CFLAGS=-std=gnu99 -I. -I/opt/intel/sgxsdk/include -Ideps/local/include -fPIC -Dsocket=seng_socket
 CFLAGSERRORS=-Wall -Wextra -Wwrite-strings -Wlogical-op -Wshadow -Werror
-CFLAGS+=$(CFLAGSERRORS) -g -O0 -DWOLFSSL_SGX_ATTESTATION -DWOLFSSL_CERT_EXT # -DDEBUG -DDYNAMIC_RSA
+CFLAGS+=$(CFLAGSERRORS) -g -O0 -DWOLFSSL_SGX_ATTESTATION -DWOLFSSL_CERT_EXT -Dsocket=seng_socket  # -DDEBUG -DDYNAMIC_RSA
 CFLAGS+=-DSGX_GROUP_OUT_OF_DATE
 
 LIBS=mbedtls/libra-attester.a \
@@ -12,7 +12,8 @@ LIBS=mbedtls/libra-attester.a \
 	wolfssl/libra-challenger.a \
 	wolfssl/libnonsdk-ra-attester.a \
 	wolfssl/libra-attester.a \
-	openssl/libra-challenger.a
+	openssl/libra-challenger.a \
+	openssl/libnonsdk-ra-attester.a
 
 .PHONY=all
 all: $(LIBS)
@@ -27,6 +28,8 @@ wolfssl-client-mutual: deps/wolfssl-examples/tls/client-tls.c ra_tls_options.c w
 
 mbedtls-client : deps/mbedtls/programs/ssl/ssl_client1.c mbedtls/libra-challenger.a
 	$(CC) -o $@ $(filter %.c, $^) $(CFLAGS) -Lmbedtls -Ldeps/local/lib -l:libra-challenger.a -l:libmbedtls.a -l:libmbedx509.a -l:libmbedcrypto.a
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output $@.manifest.sgx -exec $@ -manifest ssl-client.manifest
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output $@.token -sig $@.sig
 
 openssl-client : openssl-client.c openssl/libra-challenger.a
 	$(CC) -o $@ $(filter %.c, $^) $(CFLAGS) -Lopenssl -Ldeps/local/lib -l:libra-challenger.a -lssl -lcrypto -lm
@@ -61,8 +64,21 @@ wolfssl/libnonsdk-ra-attester.a : wolfssl wolfssl-ra.o wolfssl-ra-attester.o ias
 openssl/libra-challenger.a : openssl ra-challenger.o openssl-ra-challenger.o ias_sign_ca_cert.o
 	$(AR) rcs $@ $(filter %.o, $^)
 
+openssl/libnonsdk-ra-attester.a : openssl ra-challenger.o openssl-ra-attester.o ias-ra.o  nonsdk-ra-attester.o messages.pb-c.o sgx_report.o
+	$(AR) rcs $@ $(filter %.o, $^)
+
+
+openssl-ra-attester : openssl/libnonsdk-ra-attester.a ra_tls_options.c
+	$(CC) $(CFLAGS) -DOPENSSL $^ -o $@ -Ideps/local/include -Ldeps/local/lib -l:libcurl.a -l:libssl.a -l:libcrypto.a -l:libprotobuf-c.a -lm -l:libz.a -ldl
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output $@.manifest.sgx -exec $@ -manifest ssl-server.manifest
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output $@.token -sig $@.sig
+
+openssl-ra-challenger : openssl/libra-challenger.a
+	$(CC) $(CFLAGS) -DOPENSSL $^ -o $@ -l:libcrypto.a -ldl
+
+
 SGX_GIT=deps/linux-sgx
-EPID_SDK=$(SGX_GIT)/external/epid-sdk-3.0.0
+EPID_SDK=$(SGX_GIT)/external/epid-sdk
 
 CFLAGS+=-I$(SGX_GIT)/common/inc/internal -I$(EPID_SDK) -I$(SGX_GIT)/common/inc
 
@@ -79,7 +95,7 @@ messages.pb-c.c messages.pb-c.h :
 
 SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include -Ideps/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 MBEDTLS_SSL_SERVER_SRC=deps/mbedtls/programs/ssl/ssl_server.c \
@@ -119,13 +135,13 @@ README.html : README.md
 
 SCONE_SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include -ISCONE/deps/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 SGXLKL_SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include \
   -Isgxlkl/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 clients: mbedtls-client wolfssl-client openssl-client
@@ -155,3 +171,6 @@ mrproper: clean
 	$(RM) -r deps/curl deps/graphene deps/linux-sgx deps/linux-sgx-driver deps/mbedtls deps/wolfssl deps/wolfssl-examples
 
 .PHONY = all clean clients scone-server scone-wolfssl-ssl-server graphene-server sgxsdk-server mrproper
+
+
+
diff --git a/build.sh b/build.sh
index edd8446..5729326 100755
--- a/build.sh
+++ b/build.sh
@@ -40,7 +40,8 @@ if [ ! -d mbedtls ] ; then
     patch -p1 < ../../mbedtls-enlarge-cert-write-buffer.patch
     patch -p1 < ../../mbedtls-ssl-server.patch
     patch -p1 < ../../mbedtls-client.patch
-    cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION" . || exit 1
+    cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" . || exit 1
+    #cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" . || exit 1
     make -j`nproc` || exit 1
     cmake -D CMAKE_INSTALL_PREFIX=$(readlink -f ../local) -P cmake_install.cmake || exit 1
     popd
@@ -78,36 +79,58 @@ if [[ ! -d curl && "$VARIANT" != "scone" && "$VARIANT" != "sgxlkl" ]] ; then
     pushd curl
     git checkout curl-7_47_0
     ./buildconf
-    ./configure --prefix=$(readlink -f ../local) --without-libidn --without-librtmp --without-libssh2 --without-libmetalink --without-libpsl --with-ssl # --enable-debug
-    make -j`nproc` || exit 1
+    ./configure --prefix=$(readlink -f ../local) --without-libidn --without-librtmp --without-libssh2 --without-libmetalink --without-libpsl --with-ssl # --with-mbedtlsssl # --enable-debug
+
+    pushd lib
+    make CFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" CXXFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" -j`nproc` || exit 1
+    make install || exit 1
+    popd
+
+    pushd include
+    make CFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" CXXFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" -j`nproc` || exit 1
     make install || exit 1
     popd
+
+    popd
 fi
 
 # Linux SGX SDK code
 if [[ ! -d linux-sgx ]] ; then
     git clone https://github.com/01org/linux-sgx.git
     pushd linux-sgx
-    git checkout sgx_2.0
+    git checkout 0b493e04efe6e24d67ca6dcceb0d1af6f4010868 # same as host
+    #git checkout sgx_2.0
     popd
 fi
 
 if [[ ! -d linux-sgx-driver && $VARIANT == "graphene" ]] ; then
      git clone https://github.com/01org/linux-sgx-driver.git
      pushd linux-sgx-driver
-     git checkout sgx_driver_2.0
+     git checkout 2a509c203533f9950fa3459fe91864051bc021a2 # should be sth. between 2.1 and 2.2; same as host has
+     #git checkout sgx_driver_2.0
      popd
 fi
 
 if [[ ! -d graphene && $VARIANT == "graphene" ]] ; then
-    git clone --recursive https://github.com/oscarlab/graphene.git
+    git clone https://github.com/oscarlab/graphene.git
+    #git clone --recursive https://github.com/oscarlab/graphene.git
     pushd graphene
-    git checkout e01769337c38f67d7ccd7a7cadac4f9df0c6c65e
+    git checkout -b my_changes 58cb88d2c187358aad428b100d1ff444173e1a2b
+    patch -p1 < ../../graphene_patches.patch
+    patch -p1 < ../../fixed_exitless_syscalls_pr405.patch
+    
+    git submodule update --init --recursive
+
+    #git checkout 54f767f7ba6e1766d64543a975763066f65037af # newest version (not still races > cf. pull requests)
+    #patch -p1 < ../../pull_request_438.patch
+
     openssl genrsa -3 -out Pal/src/host/Linux-SGX/signer/enclave-key.pem 3072
     # patch -p1 < ../../graphene-sgx-linux-driver-2.1.patch
     # The Graphene build process requires two inputs: (i) SGX driver directory, (ii) driver version.
     # Unfortunately, cannot use make -j`nproc` with Graphene's build process :(
-    printf "$(readlink -f ../linux-sgx-driver)\n2.0\n" | make SGX=1 || exit 1
+    printf "$(readlink -f ../linux-sgx-driver)\n2.1\n" | make SGX=1 || exit 1
+    #printf "$(readlink -f ../linux-sgx-driver)\n2.1\n" | make SGX=1 DEBUG=1 || exit 1
+
 
     # I prefer to have all dynamic libraries in one directory. This
     # reduces the effort in the Graphene-SGX manifest file.
@@ -116,7 +139,9 @@ if [[ ! -d graphene && $VARIANT == "graphene" ]] ; then
     ln -s /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 Runtime/
     ln -s /lib/x86_64-linux-gnu/libz.so.1 Runtime/
     ln -s /lib/x86_64-linux-gnu/libssl.so.1.0.0 Runtime/
-    
+   
+    cp -P ../../graphene_runtime_symlinks/* Runtime/
+
     popd
 fi
 
@@ -148,23 +173,25 @@ fi
 popd
 
 echo "Building non-SGX-SDK sample clients ..."
-make clients || exit 1
+make messages.pb-c.c messages.pb-c.h
+SGX_MODE=HW make mbedtls/libnonsdk-ra-attester.a mbedtls/libra-challenger.a mbedtls/libra-attester.a || exit 1
+#make clients || exit 1
 make clean || exit
 
-if [ $VARIANT == "scone" ] ; then
-    bash ./build-SCONE.sh || exit 1
-    make scone-server || exit 1
-fi
+#if [ $VARIANT == "scone" ] ; then
+#    bash ./build-SCONE.sh || exit 1
+#    make scone-server || exit 1
+#fi
 
-if [ $VARIANT == "sgxlkl" ] ; then
-    make -C sgxlkl -j2 || exit 1
-fi
+#if [ $VARIANT == "sgxlkl" ] ; then
+#    make -C sgxlkl -j2 || exit 1
+#fi
 
-if [ $VARIANT == "sgxsdk" ] ; then
-    make sgxsdk-server
-fi
+#if [ $VARIANT == "sgxsdk" ] ; then
+#    make sgxsdk-server
+#fi
 
-if [ $VARIANT == "graphene" ] ; then
-    make graphene-server
-    make wolfssl-client-mutual
-fi
+#if [ $VARIANT == "graphene" ] ; then
+#    make graphene-server
+#    make wolfssl-client-mutual
+#fi
diff --git a/copy_libs_helper.bash b/copy_libs_helper.bash
new file mode 100644
index 0000000..e6a0ab8
--- /dev/null
+++ b/copy_libs_helper.bash
@@ -0,0 +1,66 @@
+#!/bin/bash
+LIBS=(/lib/x86_64-linux-gnu/libc.so.6
+/lib/x86_64-linux-gnu/libcom_err.so.2
+/lib/x86_64-linux-gnu/libcrypt.so.1
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
+/lib/x86_64-linux-gnu/libdl.so.2
+/lib/x86_64-linux-gnu/libkeyutils.so.1
+/lib/x86_64-linux-gnu/libpthread.so.0
+/lib/x86_64-linux-gnu/libresolv.so.2
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
+/lib/x86_64-linux-gnu/libz.so.1
+/usr/lib/x86_64-linux-gnu/libasn1.so.8
+/usr/lib/x86_64-linux-gnu/libcurl.so.4
+/usr/lib/x86_64-linux-gnu/libffi.so.6
+/usr/lib/x86_64-linux-gnu/libgmp.so.10
+/usr/lib/x86_64-linux-gnu/libgnutls.so.30
+/usr/lib/x86_64-linux-gnu/libgssapi.so.3
+/usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2
+/usr/lib/x86_64-linux-gnu/libhcrypto.so.4
+/usr/lib/x86_64-linux-gnu/libheimbase.so.1
+/usr/lib/x86_64-linux-gnu/libheimntlm.so.0
+/usr/lib/x86_64-linux-gnu/libhogweed.so.4
+/usr/lib/x86_64-linux-gnu/libhx509.so.5
+/usr/lib/x86_64-linux-gnu/libidn.so.11
+/usr/lib/x86_64-linux-gnu/libk5crypto.so.3
+/usr/lib/x86_64-linux-gnu/libkrb5.so.26
+/usr/lib/x86_64-linux-gnu/libkrb5.so.3
+/usr/lib/x86_64-linux-gnu/libkrb5support.so.0
+/usr/lib/x86_64-linux-gnu/liblber-2.4.so.2
+/usr/lib/x86_64-linux-gnu/libldap_r-2.4.so.2
+/usr/lib/x86_64-linux-gnu/libnettle.so.6
+/usr/lib/x86_64-linux-gnu/libp11-kit.so.0
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1
+/usr/lib/x86_64-linux-gnu/libroken.so.18
+/usr/lib/x86_64-linux-gnu/librtmp.so.1
+/usr/lib/x86_64-linux-gnu/libsasl2.so.2
+/usr/lib/x86_64-linux-gnu/libsqlite3.so.0
+/usr/lib/x86_64-linux-gnu/libtasn1.so.6
+/usr/lib/x86_64-linux-gnu/libwind.so.0)
+
+LIBS_NEW=(/home/encl-dev/sgx-ra-tls/deps/local/lib/libcurl.so.4
+/lib/x86_64-linux-gnu/libc.so.6
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
+/lib/x86_64-linux-gnu/libdl.so.2
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
+/lib/x86_64-linux-gnu/libz.so.1
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1)
+
+for l in ${LIBS[@]}
+do
+                echo "Link: deps/graphene/Runtime/`basename ${l}`"
+        if [ -e "deps/graphene/Runtime/`basename ${l}`" ]
+        then
+                echo "Link for ${l} already exists"
+        else
+                echo "${l}"
+                ln -s "${l}" deps/graphene/Runtime/
+        fi
+done
+
+echo -e "\n\n"
+
+for l in ${LIBS[@]}
+do
+		echo "sgx.trusted_files.`basename ${l} | sed -rn 's/^(lib.*).so.*$/\1/p' | tr -d '\-_.'` = file:deps/graphene/Runtime/`basename ${l}`"
+done
diff --git a/demo_libs.bash b/demo_libs.bash
new file mode 100644
index 0000000..05f3d2a
--- /dev/null
+++ b/demo_libs.bash
@@ -0,0 +1,12 @@
+#ln -s /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 ./deps/graphene/Runtime/ || exit 1
+ln -s ~/client_enclave/lwip_based_client_lib/dock_build/liblwip.so ./deps/graphene/Runtime/
+#ln -s /lib/x86_64-linux-gnu/libz.so.1 ./deps/graphene/Runtime/ || exit 1
+ln -s ~/client_enclave/lwip_based_client_lib/dock_build/dtls_tunnel_netif/src/libseng_tunnel_netif.so ./deps/graphene/Runtime/ 
+#ln -s /usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1 ./deps/graphene/Runtime/ || exit 1
+#ln -s /usr/lib/libsgx_uae_service.so ./deps/graphene/Runtime/ || exit 1
+ln -s /lib/x86_64-linux-gnu/libgcc_s.so.1 ./deps/graphene/Runtime/
+ln -s /lib/x86_64-linux-gnu/libssl.so.1.0.0 ./deps/graphene/Runtime/
+ln -s ~/client_enclave/lwip_based_client_lib/dock_build/dtls_tunnel_netif/src/libseng_onload.so ./deps/graphene/Runtime/ 
+ln -s /lib/x86_64-linux-gnu/libnss_files.so.2 ./deps/graphene/Runtime/
+ln -s /usr/lib/x86_64-linux-gnu/libprotobuf.so.9 ./deps/graphene/Runtime/
+ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 ./deps/graphene/Runtime/
diff --git a/fixed_exitless_syscalls_pr405.patch b/fixed_exitless_syscalls_pr405.patch
new file mode 100644
index 0000000..c9ba9bf
--- /dev/null
+++ b/fixed_exitless_syscalls_pr405.patch
@@ -0,0 +1,1794 @@
+diff --git a/Pal/src/host/Linux-SGX/Makefile b/Pal/src/host/Linux-SGX/Makefile
+index 305c8f0199..6aaa367436 100644
+--- a/Pal/src/host/Linux-SGX/Makefile
++++ b/Pal/src/host/Linux-SGX/Makefile
+@@ -9,9 +9,9 @@ defs	= -DIN_PAL -DPAL_DIR=$(PAL_DIR) -DRUNTIME_DIR=$(RUNTIME_DIR)
+ enclave-objs = $(addprefix db_,files devices pipes sockets streams memory \
+ 		 threading mutex events process object main rtld \
+ 		 exception misc ipc spinlock) \
+-	       $(addprefix enclave_,ocalls ecalls framework pages untrusted) 
++	       $(addprefix enclave_,ocalls ecalls framework pages untrusted rpcqueue)
+ enclave-asm-objs = enclave_entry 
+-urts-objs = $(addprefix sgx_,enclave framework main rtld thread process exception graphene)
++urts-objs = $(addprefix sgx_,enclave framework main rtld thread process exception graphene rpcqueue)
+ urts-asm-objs = sgx_entry
+ graphene_lib = .lib/graphene-lib.a
+ headers	= $(wildcard *.h) $(wildcard ../../*.h) $(wildcard ../../../lib/*.h) \
+diff --git a/Pal/src/host/Linux-SGX/db_exception.c b/Pal/src/host/Linux-SGX/db_exception.c
+index 4ce10e7423..7ed68a192c 100644
+--- a/Pal/src/host/Linux-SGX/db_exception.c
++++ b/Pal/src/host/Linux-SGX/db_exception.c
+@@ -127,7 +127,7 @@ extern void arch_exception_return (void) __asm__ ("arch_exception_return_asm");
+ void _DkExceptionRealHandler (int event, PAL_NUM arg, struct pal_frame * frame,
+                               PAL_CONTEXT * context)
+ {
+-    if (frame) {
++    if (!frame) {
+         frame = __alloca(sizeof(struct pal_frame));
+         frame->identifier = PAL_FRAME_IDENTIFIER;
+         frame->func     = &_DkExceptionRealHandler;
+diff --git a/Pal/src/host/Linux-SGX/ecall_types.h b/Pal/src/host/Linux-SGX/ecall_types.h
+index 437cd98255..8acb84f133 100644
+--- a/Pal/src/host/Linux-SGX/ecall_types.h
++++ b/Pal/src/host/Linux-SGX/ecall_types.h
+@@ -8,9 +8,11 @@ enum {
+ };
+ 
+ struct pal_sec;
++struct rpc_queue;
+ 
+ typedef struct {
+     const char ** ms_arguments;
+     const char ** ms_environments;
+     struct pal_sec * ms_sec_info;
++    struct rpc_queue * rpc_queue; /* pointer to RPC queue in untrusted mem */
+ } ms_ecall_enclave_start_t;
+diff --git a/Pal/src/host/Linux-SGX/enclave_ecalls.c b/Pal/src/host/Linux-SGX/enclave_ecalls.c
+index b01d7f96f8..9879175fac 100644
+--- a/Pal/src/host/Linux-SGX/enclave_ecalls.c
++++ b/Pal/src/host/Linux-SGX/enclave_ecalls.c
+@@ -7,6 +7,7 @@
+ #include <api.h>
+ 
+ #include "ecall_types.h"
++#include "rpcqueue.h"
+ 
+ #define SGX_CAST(type, item) ((type) (item))
+ 
+@@ -17,6 +18,28 @@ void pal_start_thread (void);
+ 
+ extern void * enclave_base, * enclave_top;
+ 
++/* returns 0 if rpc_queue is valid, otherwise 1 */
++static int set_rpc_queue(rpc_queue_t* untrusted_rpc_queue) {
++    g_rpc_queue = untrusted_rpc_queue;
++    if (!g_rpc_queue)
++        return 0;
++
++    if (sgx_is_within_enclave(g_rpc_queue, sizeof(*g_rpc_queue)))
++        return 1;
++
++    if (g_rpc_queue->rpc_threads_num > MAX_RPC_THREADS)
++        return 1;
++
++    /* re-initialize rest fields for safety */
++    atomic_set(&g_rpc_queue->lock, SPIN_UNLOCKED);
++    g_rpc_queue->front = 0;
++    g_rpc_queue->rear  = 0;
++    for (size_t i = 0; i < RPC_QUEUE_SIZE; i++)
++        g_rpc_queue->q[i] = NULL;
++
++    return 0;
++}
++
+ int handle_ecall (long ecall_index, void * ecall_args, void * exit_target,
+                   void * untrusted_stack, void * enclave_base_addr)
+ {
+@@ -45,6 +68,9 @@ int handle_ecall (long ecall_index, void * ecall_args, void * exit_target,
+ 
+             if (!ms) return -PAL_ERROR_INVAL;
+ 
++            if (set_rpc_queue(ms->rpc_queue))
++                return -PAL_ERROR_DENIED;
++
+             pal_linux_main(ms->ms_arguments, ms->ms_environments,
+                            ms->ms_sec_info);
+             break;
+diff --git a/Pal/src/host/Linux-SGX/enclave_framework.c b/Pal/src/host/Linux-SGX/enclave_framework.c
+index bbc914d97a..1a5809389d 100644
+--- a/Pal/src/host/Linux-SGX/enclave_framework.c
++++ b/Pal/src/host/Linux-SGX/enclave_framework.c
+@@ -24,6 +24,27 @@ bool sgx_is_within_enclave (const void * addr, uint64_t size)
+     return enclave_base <= addr && addr + size <= enclave_top;
+ }
+ 
++/* The following three functions are used to push and pop frames from
++ * enclave thread's untrusted stack in the following manner:
++ *
++ *    // get new stack frame on enclave thread's untrusted stack
++ *    void* frame = sgx_ocget_frame();
++ *
++ *    // allocate some objects on the new stack frame
++ *    object1_t* obj1 = sgx_ocalloc(sizeof(*obj1));
++ *    object2_t* obj2 = sgx_ocalloc(sizeof(*obj2));
++ *
++ *    // free (pop) this stack frame; this automatically frees objects
++ *    sgx_ocfree_frame(frame);
++ *
++ * These functions do not fail; in case of stack overflow, program behavior
++ * is undefined (interface similar to alloca).
++ */
++void * sgx_ocget_frame (void)
++{
++    return GET_ENCLAVE_TLS(ustack);
++}
++
+ void * sgx_ocalloc (uint64_t size)
+ {
+     void * ustack = GET_ENCLAVE_TLS(ustack) - size;
+@@ -31,9 +52,9 @@ void * sgx_ocalloc (uint64_t size)
+     return ustack;
+ }
+ 
+-void sgx_ocfree (void)
++void sgx_ocfree_frame (void * frame)
+ {
+-    SET_ENCLAVE_TLS(ustack, GET_ENCLAVE_TLS(ustack_top));
++    SET_ENCLAVE_TLS(ustack, frame);
+ }
+ 
+ int sgx_get_report (sgx_arch_hash_t * mrenclave,
+diff --git a/Pal/src/host/Linux-SGX/enclave_ocalls.c b/Pal/src/host/Linux-SGX/enclave_ocalls.c
+index d1425bce6f..ce9326015b 100644
+--- a/Pal/src/host/Linux-SGX/enclave_ocalls.c
++++ b/Pal/src/host/Linux-SGX/enclave_ocalls.c
+@@ -6,6 +6,7 @@
+  */
+ 
+ #include "pal_linux.h"
++#include "pal_linux_error.h"
+ #include "pal_internal.h"
+ #include "pal_debug.h"
+ #include "enclave_ocalls.h"
+@@ -14,106 +15,201 @@
+ #include <api.h>
+ 
+ #include <asm/errno.h>
++#include <linux/futex.h>
++#include "rpcqueue.h"
+ 
+-#define OCALLOC(val, type, len) do {    \
+-    void * _tmp = sgx_ocalloc(len);     \
+-    if (_tmp == NULL) {                 \
+-        OCALL_EXIT();                   \
+-        return -PAL_ERROR_DENIED;  /* TODO: remove this control-flow obfuscation */  \
+-    }                                   \
+-    (val) = (type) _tmp;                \
+-} while (0)
+-
+-int printf(const char * fmt, ...);
+-
+-#define SGX_OCALL(code, ms) sgx_ocall(code, ms)
+-
+-#define OCALL_EXIT()                                    \
+-    do {                                                \
+-        sgx_ocfree();                                   \
+-    } while (0)
+-
+-#define ALLOC_IN_USER(ptr, size)                    \
+-    ({                                              \
+-        __typeof__(ptr) tmp = ptr;                  \
+-        if (sgx_is_within_enclave(ptr, size)) {     \
+-            OCALLOC(tmp, __typeof__(tmp), size);    \
+-        }; tmp;                                     \
+-    })
+-
+-#define COPY_TO_USER(ptr, size)                     \
+-    ({                                              \
+-        __typeof__(ptr) tmp = ptr;                  \
+-        if (sgx_is_within_enclave(ptr, size)) {     \
+-            OCALLOC(tmp, __typeof__(tmp), size);    \
+-            memcpy((void *) tmp, ptr, size);        \
+-        }; tmp;                                     \
+-    })
+-
+-#define COPY_FROM_USER(var, user_var, size)                 \
+-    ({                                                      \
+-        int _ret = 0;                                       \
+-        if (var != user_var) {                              \
+-            if (sgx_is_within_enclave(user_var, size) ||    \
+-                !sgx_is_within_enclave(var, size)) {        \
+-                _ret = -PAL_ERROR_DENIED;                   \
+-            } else {                                        \
+-                _ret = 0;                                   \
+-                memcpy(var, user_var, size);                \
+-            }                                               \
+-        } _ret;                                             \
+-    })
++rpc_queue_t* g_rpc_queue;  /* pointer to untrusted queue */
++
++static void* alloc_in_user(void* ptr, uint64_t size) {
++    if (!sgx_is_within_enclave(ptr, size))
++        return ptr;
++
++    /* we assume that sgx_ocalloc never fails because it allocates on stack
++     * (interface similar to alloca); for same reason there is no sgx_ocfree */
++    return sgx_ocalloc(size);
++}
++
++static void* copy_to_user(const void* ptr, uint64_t size) {
++    if (!sgx_is_within_enclave(ptr, size))
++        return (void*)ptr;
++
++    void* tmp = sgx_ocalloc(size);
++    memcpy(tmp, ptr, size);
++    return tmp;
++}
++
++static void copy_from_user(void* ptr, const void* user_ptr, uint64_t size) {
++    if (sgx_is_within_enclave(user_ptr, size) ||
++            !sgx_is_within_enclave(ptr, size))
++        return;
++
++    memcpy(ptr, user_ptr, size);
++}
++
++static int sgx_exitless_ocall(int code, void* ms) {
++    /* perform OCALL with enclave exit if no RPC queue */
++    if (!g_rpc_queue)
++        return sgx_ocall(code, ms);
++
++    /* allocate request on OCALL stack; it is automatically freed on OCALL end;
++     * note that request's lock is used in futex() and must be aligned to 4B
++     * so we pad OCALL stack to 4B alignment with dummy chars */
++    char* dummy;
++    do {
++        dummy = sgx_ocalloc(sizeof(*dummy));
++    } while ((uint64_t)dummy % 4 != 0);
++
++    rpc_request_t* req = sgx_ocalloc(sizeof(*req));
++    req->ocall_index = code;
++    req->buffer      = ms;
++    atomic_set(&req->lock, REQ_LOCKED_NO_WAITERS);
++
++    /* enqueue OCALL into RPC queue; some RPC thread will dequeue it, issue a syscall
++     * and, after syscall is finished, unlock it by setting lock=REQ_UNLOCKED */
++    req = rpc_enqueue(g_rpc_queue, req);
++    if (!req) {
++        /* no space in queue: all RPC threads are busy with outstanding ocalls */
++        return -ENOMEM;
++    }
++
++    /* wait till request processing is finished; try spinlock first */
++    int timedout = rpc_spin_lock_timeout(&req->lock, RPC_SPIN_LOCK_TIMEOUT);
++
++    /* at this point:
++     * - either RPC thread is done with OCALL and moved lock in REQ_UNLOCKED state,
++     *   and our enclave thread grabbed lock but it doesn't matter at this point
++     *   (OCALL is done, timedout = 0, no need to wait on futex)
++     * - or OCALL is still pending and lock is still in REQ_LOCKED_NO_WAITERS
++     *   (OCALL is not done, timedout != 0, let's wait on futex) */
++
++    if (timedout) {
++        /* OCALL takes a lot of time, so fallback to waiting on a futex;
++         * note that at this point we exit the enclave to perform syscall;
++         * this code is based on Mutex 2 from Futexes are Tricky */
++        int c;
++
++        /* at this point can be a subtle data race: RPC thread is only now done
++         * with OCALL and moved lock in REQ_UNLOCKED state; in this racey case,
++         * lock = REQ_UNLOCKED = 0 and we do not wait on futex (note that our enclave
++         * thread grabbed lock but it doesn't matter at this point) */
++        if ((c = atomic_cmpxchg(&req->lock, REQ_UNLOCKED, REQ_LOCKED_NO_WAITERS))) {
++            do {
++                /* at this point lock = REQ_LOCKED_*; before waiting on futex, need to
++                 * move lock to REQ_LOCKED_WITH_WAITERS; note that check on cmpxchg of
++                 * lock = REQ_UNLOCKED = 0 is for the same data race as above */
++                if (c == REQ_LOCKED_WITH_WAITERS ||  /* shortcut: don't need to move lock state */
++                    atomic_cmpxchg(&req->lock, REQ_LOCKED_NO_WAITERS, REQ_LOCKED_WITH_WAITERS)) {
++
++                    /* allocate futex args on OCALL stack; automatically freed on OCALL end */
++                    ms_ocall_futex_t * ms = sgx_ocalloc(sizeof(*ms));
++                    ms->ms_futex = (int*)&req->lock.counter;
++                    ms->ms_op = FUTEX_WAIT_PRIVATE;
++                    ms->ms_val = REQ_LOCKED_WITH_WAITERS;
++                    ms->ms_timeout = OCALL_NO_TIMEOUT;
++
++                    /* at this point, futex(wait) syscall expects lock to be in state
++                     * REQ_LOCKED_WITH_WAITERS set by enclave thread above; if RPC
++                     * thread moved it back to REQ_UNLOCKED, futex() immediately returns */
++                    int ret = sgx_ocall(OCALL_FUTEX, ms);
++                    if (ret < 0 && ret != -PAL_ERROR_TRYAGAIN)
++                        return -ENOMEM;
++                }
++            } while ((c = atomic_cmpxchg(&req->lock, REQ_UNLOCKED, REQ_LOCKED_WITH_WAITERS)));
++            /* while-loop is required for spurious futex wake-ups: our enclave thread
++             * must wait until lock moves to REQ_UNLOCKED (note that enclave thread
++             * grabs lock but it doesn't matter at this point) */
++        }
++    }
++
++    return req->result;
++}
++
++/* Adding new OCALLs (syscalls):
++ *   1. Add new enum for OCALL (in ocall_types.h)
++ *   2. Add new ms_ocall_*_t struct which captures all OCALL args (in ocall_types.h)
++ *   3. Add new sgx_*() function which is executed in untrusted PAL and issues
++ *      an actual syscall (in sgx_enclave.c)
++ *   4. Register this sgx_*() function in ocall_table (in sgx_enclave.c)
++ *   5. Add new ocall_*() function which is executed in trusted PAL and performs
++ *      an OCALL into untrusted PAL to call sgx_*()
++ *
++ * For step (5), the pattern to write new ocall_*() function is:
++ *
++ * int ocall_new_syscall (void* arg1, void* arg2) {
++ *    int retval = 0;
++ *
++ *    // get new stack frame on enclave thread's untrusted stack (OCALL stack)
++ *    void* frame = sgx_ocget_frame();
++ *
++ *    // push struct with all OCALL args on current OCALL stack frame
++ *    ms_ocall_new_syscall_t * ms = sgx_ocalloc(sizeof(*ms));
++ *    ms->ms_arg1 = arg1;
++ *    ms->ms_arg2 = arg2;
++ *
++ *    // perform exitless OCALL
++ *    retval = sgx_exitless_ocall(OCALL_NEW_SYSCALL, ms);
++ *
++ *    // free (pop) current OCALL stack frame and return;
++ *    // this automatically frees all args pushed on OCALL stack
++ *    sgx_ocfree_frame(frame);
++ *    return retval;
++ * }
++ *
++ * Most new syscalls should use sgx_exitless_ocall() for performance reasons.
++ * If new syscall _needs_ to perform enclave exit, replace with sgx_ocall().
++ */
+ 
+ int ocall_exit(int exitcode)
+ {
+     int64_t code = exitcode;
+     // There are two reasons for this loop:
+     //  1. Ocalls can be interuppted.
+     //  2. We can't trust the outside to actually exit, so we need to ensure
+     //     that we never return even when the outside tries to trick us.
+     while (true) {
+-        SGX_OCALL(OCALL_EXIT, (void *) code);
++        sgx_ocall(OCALL_EXIT, (void *) code);
+     }
+     return 0;
+ }
+ 
+ int ocall_print_string (const char * str, unsigned int length)
+ {
+     int retval = 0;
+-    ms_ocall_print_string_t * ms;
+-    OCALLOC(ms, ms_ocall_print_string_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
+     if (!str || length <= 0) {
+-        OCALL_EXIT();
++        sgx_ocfree_frame(frame);
+         return -PAL_ERROR_DENIED;
+     }
+ 
+-    ms->ms_str = COPY_TO_USER(str, length);
++    ms_ocall_print_string_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_str = copy_to_user(str, length);
+     ms->ms_length = length;
+ 
+-    retval = SGX_OCALL(OCALL_PRINT_STRING, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_PRINT_STRING, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_alloc_untrusted (uint64_t size, void ** mem)
+ {
+     int retval = 0;
+-    ms_ocall_alloc_untrusted_t * ms;
+-
+-    OCALLOC(ms, ms_ocall_alloc_untrusted_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_alloc_untrusted_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_size = size;
+ 
+-    retval = SGX_OCALL(OCALL_ALLOC_UNTRUSTED, ms);
++    retval = sgx_exitless_ocall(OCALL_ALLOC_UNTRUSTED, ms);
+     if (!retval) {
+         if (sgx_is_within_enclave(ms->ms_mem, size)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+         *mem = ms->ms_mem;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -118,44 +214,44 @@ int ocall_map_untrusted (int fd, uint64_t offset,
+                          void ** mem)
+ {
+     int retval = 0;
+-    ms_ocall_map_untrusted_t * ms;
+-
+-    OCALLOC(ms, ms_ocall_map_untrusted_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_map_untrusted_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     ms->ms_offset = offset;
+     ms->ms_size = size;
+     ms->ms_prot = prot;
+ 
+-    retval = SGX_OCALL(OCALL_MAP_UNTRUSTED, ms);
++    retval = sgx_exitless_ocall(OCALL_MAP_UNTRUSTED, ms);
+     if (!retval) {
+         if (sgx_is_within_enclave(ms->ms_mem, size)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+         *mem = ms->ms_mem;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_unmap_untrusted (const void * mem, uint64_t size)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
+ 
+     if (sgx_is_within_enclave(mem, size)) {
+-        OCALL_EXIT();
++        sgx_ocfree_frame(frame);
+         return -PAL_ERROR_INVAL;
+     }
+ 
+-    ms_ocall_unmap_untrusted_t * ms;
+-    OCALLOC(ms, ms_ocall_unmap_untrusted_t *, sizeof(*ms));
+-
++    ms_ocall_unmap_untrusted_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_mem  = mem;
+     ms->ms_size = size;
+ 
+-    retval = SGX_OCALL(OCALL_UNMAP_UNTRUSTED, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_UNMAP_UNTRUSTED, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -163,13 +259,13 @@ int ocall_cpuid (unsigned int leaf, unsigned int subleaf,
+                  unsigned int values[4])
+ {
+     int retval = 0;
+-    ms_ocall_cpuid_t * ms;
+-    OCALLOC(ms, ms_ocall_cpuid_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_cpuid_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_leaf = leaf;
+     ms->ms_subleaf = subleaf;
+ 
+-    retval = SGX_OCALL(OCALL_CPUID, ms);
++    retval = sgx_exitless_ocall(OCALL_CPUID, ms);
+     if (!retval) {
+         values[0] = ms->ms_values[0];
+         values[1] = ms->ms_values[1];
+@@ -177,42 +273,47 @@ int ocall_cpuid (unsigned int leaf, unsigned int subleaf,
+         values[3] = ms->ms_values[3];
+     }
+ 
+-    OCALL_EXIT();
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_open (const char * pathname, int flags, unsigned short mode)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int len = pathname ? strlen(pathname) + 1 : 0;
+-    ms_ocall_open_t * ms;
+-    OCALLOC(ms, ms_ocall_open_t *, sizeof(*ms));
+ 
+-    ms->ms_pathname = COPY_TO_USER(pathname, len);
++    ms_ocall_open_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_pathname = copy_to_user(pathname, len);
+     ms->ms_flags = flags;
+     ms->ms_mode = mode;
+ 
+-    retval = SGX_OCALL(OCALL_OPEN, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_OPEN, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_close (int fd)
+ {
+     int retval = 0;
+-    ms_ocall_close_t *ms;
+-    OCALLOC(ms, ms_ocall_close_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_close_t *ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+ 
+-    retval = SGX_OCALL(OCALL_CLOSE, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_CLOSE, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_read (int fd, void * buf, unsigned int count)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     void * obuf = NULL;
+ 
+     if (count > 4096) {
+@@ -221,21 +322,20 @@ int ocall_read (int fd, void * buf, unsigned int count)
+             return retval;
+     }
+ 
+-    ms_ocall_read_t * ms;
+-    OCALLOC(ms, ms_ocall_read_t *, sizeof(*ms));
+-
++    ms_ocall_read_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     if (obuf)
+         ms->ms_buf = obuf;
+     else
+-        OCALLOC(ms->ms_buf, void *, count);
++        ms->ms_buf = sgx_ocalloc(count);
+     ms->ms_count = count;
+ 
+-    retval = SGX_OCALL(OCALL_READ, ms);
++    retval = sgx_exitless_ocall(OCALL_READ, ms);
+ 
+     if (retval > 0)
+         memcpy(buf, ms->ms_buf, retval);
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+ 
+     if (obuf)
+         ocall_unmap_untrusted(obuf, ALLOC_ALIGNUP(count));
+@@ -246,6 +346,8 @@ int ocall_read (int fd, void * buf, unsigned int count)
+ int ocall_write (int fd, const void * buf, unsigned int count)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     void * obuf = NULL;
+ 
+     if (count > 4096) {
+@@ -254,20 +356,19 @@ int ocall_write (int fd, const void * buf, unsigned int count)
+             return retval;
+     }
+ 
+-    ms_ocall_write_t * ms;
+-    OCALLOC(ms, ms_ocall_write_t *, sizeof(*ms));
+-
++    ms_ocall_write_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     if (obuf) {
+         ms->ms_buf = obuf;
+         memcpy(obuf, buf, count);
+     } else {
+-        ms->ms_buf = COPY_TO_USER(buf, count);
++        ms->ms_buf = copy_to_user(buf, count);
+     }
+     ms->ms_count = count;
+ 
+-    retval = SGX_OCALL(OCALL_WRITE, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_WRITE, ms);
++
++    sgx_ocfree_frame(frame);
+ 
+     if (obuf)
+         ocall_unmap_untrusted(obuf, ALLOC_ALIGNUP(count));
+@@ -278,121 +379,132 @@ int ocall_write (int fd, const void * buf, unsigned int count)
+ int ocall_fstat (int fd, struct stat * buf)
+ {
+     int retval = 0;
+-    ms_ocall_fstat_t * ms;
+-    OCALLOC(ms, ms_ocall_fstat_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_fstat_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+ 
+-    retval = SGX_OCALL(OCALL_FSTAT, ms);
++    retval = sgx_exitless_ocall(OCALL_FSTAT, ms);
+     if (!retval)
+         memcpy(buf, &ms->ms_stat, sizeof(struct stat));
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_fionread (int fd)
+ {
+     int retval = 0;
+-    ms_ocall_fionread_t * ms;
+-    OCALLOC(ms, ms_ocall_fionread_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_fionread_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+ 
+-    retval = SGX_OCALL(OCALL_FIONREAD, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FIONREAD, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_fsetnonblock (int fd, int nonblocking)
+ {
+     int retval = 0;
+-    ms_ocall_fsetnonblock_t * ms;
+-    OCALLOC(ms, ms_ocall_fsetnonblock_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_fsetnonblock_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     ms->ms_nonblocking = nonblocking;
+ 
+-    retval = SGX_OCALL(OCALL_FSETNONBLOCK, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FSETNONBLOCK, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_fchmod (int fd, unsigned short mode)
+ {
+     int retval = 0;
+-    ms_ocall_fchmod_t * ms;
+-    OCALLOC(ms, ms_ocall_fchmod_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_fchmod_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     ms->ms_mode = mode;
+ 
+-    retval = SGX_OCALL(OCALL_FCHMOD, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FCHMOD, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_fsync (int fd)
+ {
+     int retval = 0;
+-    ms_ocall_fsync_t * ms;
+-    OCALLOC(ms, ms_ocall_fsync_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_fsync_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+ 
+-    retval = SGX_OCALL(OCALL_FSYNC, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FSYNC, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_ftruncate (int fd, uint64_t length)
+ {
+     int retval = 0;
+-    ms_ocall_ftruncate_t * ms;
+-    OCALLOC(ms, ms_ocall_ftruncate_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_ftruncate_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+     ms->ms_length = length;
+ 
+-    retval = SGX_OCALL(OCALL_FTRUNCATE, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FTRUNCATE, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_mkdir (const char * pathname, unsigned short mode)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int len = pathname ? strlen(pathname) + 1 : 0;
+-    ms_ocall_mkdir_t * ms;
+-    OCALLOC(ms, ms_ocall_mkdir_t *, sizeof(*ms));
+ 
+-    ms->ms_pathname = COPY_TO_USER(pathname, len);
++    ms_ocall_mkdir_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_pathname = copy_to_user(pathname, len);
+     ms->ms_mode = mode;
+ 
+-    retval = SGX_OCALL(OCALL_MKDIR, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_MKDIR, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_getdents (int fd, struct linux_dirent64 * dirp, unsigned int size)
+ {
+     int retval = 0;
+-    ms_ocall_getdents_t * ms;
+-    OCALLOC(ms, ms_ocall_getdents_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_getdents_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_fd = fd;
+-    ms->ms_dirp = ALLOC_IN_USER(dirp, size);
++    ms->ms_dirp = alloc_in_user(dirp, size);
+     ms->ms_size = size;
+ 
+-    retval = SGX_OCALL(OCALL_GETDENTS, ms);
++    retval = sgx_exitless_ocall(OCALL_GETDENTS, ms);
+     if (retval > 0)
+-        COPY_FROM_USER(dirp, ms->ms_dirp, retval);
+-    OCALL_EXIT();
++        copy_from_user(dirp, ms->ms_dirp, retval);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_wake_thread (void * tcs)
+ {
+-    return SGX_OCALL(OCALL_WAKE_THREAD, tcs);
++    /* NOTE: since this can be executed from within signal handler and sends
++     *       SIGCONT to other enclave threads, cannot use exitless here */
++    return sgx_ocall(OCALL_WAKE_THREAD, tcs);
+ }
+ 
+ int ocall_create_process (const char * uri,
+@@ -401,19 +513,19 @@ int ocall_create_process (const char * uri,
+                           unsigned int * pid)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int ulen = uri ? strlen(uri) + 1 : 0;
+-    ms_ocall_create_process_t * ms;
+-    OCALLOC(ms, ms_ocall_create_process_t *,
+-            sizeof(*ms) + sizeof(const char *) * nargs);
+ 
+-    ms->ms_uri = uri ? COPY_TO_USER(uri, ulen) : NULL;
++    ms_ocall_create_process_t * ms = sgx_ocalloc(sizeof(*ms) + sizeof(char *) * nargs);
++    ms->ms_uri = uri ? copy_to_user(uri, ulen) : NULL;
+     ms->ms_nargs = nargs;
+     for (int i = 0 ; i < nargs ; i++) {
+         int len = args[i] ? strlen(args[i]) + 1 : 0;
+-        ms->ms_args[i] = args[i] ? COPY_TO_USER(args[i], len) : NULL;
++        ms->ms_args[i] = args[i] ? copy_to_user(args[i], len) : NULL;
+     }
+ 
+-    retval = SGX_OCALL(OCALL_CREATE_PROCESS, ms);
++    retval = sgx_exitless_ocall(OCALL_CREATE_PROCESS, ms);
+     if (!retval) {
+         if (pid)
+             *pid = ms->ms_pid;
+@@ -421,7 +533,8 @@ int ocall_create_process (const char * uri,
+         procfds[1] = ms->ms_proc_fds[1];
+         procfds[2] = ms->ms_proc_fds[2];
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -429,21 +542,22 @@ int ocall_futex (int * futex, int op, int val,
+                  const uint64_t * timeout)
+ {
+     int retval = 0;
+-    ms_ocall_futex_t * ms;
+-    OCALLOC(ms, ms_ocall_futex_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
+     if (sgx_is_within_enclave(futex, sizeof(int))) {
+-        OCALL_EXIT();
++        sgx_ocfree_frame(frame);
+         return -PAL_ERROR_INVAL;
+     }
+ 
++    ms_ocall_futex_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_futex = futex;
+     ms->ms_op = op;
+     ms->ms_val = val;
+     ms->ms_timeout = timeout ? *timeout : OCALL_NO_TIMEOUT;
+ 
+-    retval = SGX_OCALL(OCALL_FUTEX, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_FUTEX, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -451,19 +565,20 @@ int ocall_socketpair (int domain, int type, int protocol,
+                       int sockfds[2])
+ {
+     int retval = 0;
+-    ms_ocall_socketpair_t * ms;
+-    OCALLOC(ms, ms_ocall_socketpair_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_socketpair_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_domain = domain;
+     ms->ms_type = type;
+     ms->ms_protocol = protocol;
+ 
+-    retval = SGX_OCALL(OCALL_SOCKETPAIR, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCKETPAIR, ms);
+     if (!retval) {
+         sockfds[0] = ms->ms_sockfds[0];
+         sockfds[1] = ms->ms_sockfds[1];
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -472,33 +587,35 @@ int ocall_sock_listen (int domain, int type, int protocol,
+                        struct sockopt * sockopt)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     unsigned int bind_len = *addrlen;
+-    ms_ocall_sock_listen_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_listen_t *, sizeof(*ms));
+ 
++    ms_ocall_sock_listen_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_domain = domain;
+     ms->ms_type = type;
+     ms->ms_protocol = protocol;
+-    ms->ms_addr = COPY_TO_USER(addr, bind_len);
++    ms->ms_addr = copy_to_user(addr, bind_len);
+     ms->ms_addrlen = bind_len;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_LISTEN, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCK_LISTEN, ms);
+     if (retval >= 0) {
+         if (addrlen && (
+             sgx_is_within_enclave(ms->ms_addr, bind_len) ||
+             ms->ms_addrlen > bind_len)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+ 
+         if (addr) {
+-            COPY_FROM_USER(addr, ms->ms_addr, ms->ms_addrlen);
++            copy_from_user(addr, ms->ms_addr, ms->ms_addrlen);
+             *addrlen = ms->ms_addrlen;
+         }
+         if (sockopt)
+             *sockopt = ms->ms_sockopt;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -506,30 +623,32 @@ int ocall_sock_accept (int sockfd, struct sockaddr * addr,
+                        unsigned int * addrlen, struct sockopt * sockopt)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     unsigned int len = addrlen ? *addrlen : 0;
+-    ms_ocall_sock_accept_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_accept_t *, sizeof(*ms));
+ 
++    ms_ocall_sock_accept_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+-    ms->ms_addr = COPY_TO_USER(addr, len);
++    ms->ms_addr = copy_to_user(addr, len);
+     ms->ms_addrlen = len;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_ACCEPT, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCK_ACCEPT, ms);
+     if (retval >= 0) {
+         if (len && (sgx_is_within_enclave(ms->ms_addr, len) ||
+                     ms->ms_addrlen > len)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+ 
+         if (addr) {
+-            COPY_FROM_USER(addr, ms->ms_addr, ms->ms_addrlen);
++            copy_from_user(addr, ms->ms_addr, ms->ms_addrlen);
+             *addrlen = ms->ms_addrlen;
+         }
+         if (sockopt)
+             *sockopt = ms->ms_sockopt;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -540,36 +659,38 @@ int ocall_sock_connect (int domain, int type, int protocol,
+                         unsigned int * bind_addrlen, struct sockopt * sockopt)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     unsigned int bind_len = bind_addrlen ? *bind_addrlen : 0;
+-    ms_ocall_sock_connect_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_connect_t *, sizeof(*ms));
+ 
++    ms_ocall_sock_connect_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_domain = domain;
+     ms->ms_type = type;
+     ms->ms_protocol = protocol;
+-    ms->ms_addr = COPY_TO_USER(addr, addrlen);
++    ms->ms_addr = copy_to_user(addr, addrlen);
+     ms->ms_addrlen = addrlen;
+-    ms->ms_bind_addr = bind_addr ? COPY_TO_USER(bind_addr, bind_len) : NULL;
++    ms->ms_bind_addr = bind_addr ? copy_to_user(bind_addr, bind_len) : NULL;
+     ms->ms_bind_addrlen = bind_len;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_CONNECT, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCK_CONNECT, ms);
+     if (retval >= 0) {
+         if (bind_len && (
+             sgx_is_within_enclave(ms->ms_bind_addr, bind_len) ||
+             ms->ms_bind_addrlen > bind_len)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+ 
+         if (bind_addr) {
+-            COPY_FROM_USER(bind_addr, ms->ms_bind_addr,
++            copy_from_user(bind_addr, ms->ms_bind_addr,
+                            ms->ms_bind_addrlen);
+             *bind_addrlen = ms->ms_bind_addrlen;
+         }
+         if (sockopt)
+             *sockopt = ms->ms_sockopt;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -577,30 +698,32 @@ int ocall_sock_recv (int sockfd, void * buf, unsigned int count,
+                      struct sockaddr * addr, unsigned int * addrlen)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     unsigned int len = addrlen ? *addrlen : 0;
+-    ms_ocall_sock_recv_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_recv_t *, sizeof(*ms));
+ 
++    ms_ocall_sock_recv_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+-    ms->ms_buf = ALLOC_IN_USER(buf, count);
++    ms->ms_buf = alloc_in_user(buf, count);
+     ms->ms_count = count;
+-    ms->ms_addr = addr ? ALLOC_IN_USER(addr, len) : NULL;
++    ms->ms_addr = addr ? alloc_in_user(addr, len) : NULL;
+     ms->ms_addrlen = len;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_RECV, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCK_RECV, ms);
+     if (retval >= 0) {
+         if (len && (sgx_is_within_enclave(ms->ms_addr, len) ||
+                     ms->ms_addrlen > len)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+ 
+-        COPY_FROM_USER(buf, ms->ms_buf, retval);
+-        COPY_FROM_USER(addr, ms->ms_addr, ms->ms_addrlen);
++        copy_from_user(buf, ms->ms_buf, retval);
++        copy_from_user(addr, ms->ms_addr, ms->ms_addrlen);
+         if (addrlen)
+             *addrlen = ms->ms_addrlen;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -608,17 +731,18 @@ int ocall_sock_send (int sockfd, const void * buf, unsigned int count,
+                      const struct sockaddr * addr, unsigned int addrlen)
+ {
+     int retval = 0;
+-    ms_ocall_sock_send_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_send_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sock_send_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+-    ms->ms_buf = COPY_TO_USER(buf, count);
++    ms->ms_buf = copy_to_user(buf, count);
+     ms->ms_count = count;
+-    ms->ms_addr = addr ? COPY_TO_USER(addr, addrlen) : NULL;
++    ms->ms_addr = addr ? copy_to_user(addr, addrlen) : NULL;
+     ms->ms_addrlen = addrlen;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_SEND, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_SOCK_SEND, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -626,28 +750,29 @@ int ocall_sock_recv_fd (int sockfd, void * buf, unsigned int count,
+                         unsigned int * fds, unsigned int * nfds)
+ {
+     int retval = 0;
+-    ms_ocall_sock_recv_fd_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_recv_fd_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sock_recv_fd_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+-    ms->ms_buf = ALLOC_IN_USER(buf, count);
++    ms->ms_buf = alloc_in_user(buf, count);
+     ms->ms_count = count;
+-    ms->ms_fds = fds ? ALLOC_IN_USER(fds, sizeof(int) * (*nfds)) : NULL;
++    ms->ms_fds = fds ? alloc_in_user(fds, sizeof(int) * (*nfds)) : NULL;
+     ms->ms_nfds = *nfds;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_RECV_FD, ms);
++    retval = sgx_exitless_ocall(OCALL_SOCK_RECV_FD, ms);
+     if (retval >= 0) {
+         if (sgx_is_within_enclave(ms->ms_fds, sizeof(int) * (*nfds)) ||
+             ms->ms_nfds > (*nfds)) {
+-            OCALL_EXIT();
++            sgx_ocfree_frame(frame);
+             return -PAL_ERROR_DENIED;
+         }
+ 
+-        COPY_FROM_USER(buf, ms->ms_buf, retval);
+-        COPY_FROM_USER(fds, ms->ms_fds, sizeof(int) * ms->ms_nfds);
++        copy_from_user(buf, ms->ms_buf, retval);
++        copy_from_user(fds, ms->ms_fds, sizeof(int) * ms->ms_nfds);
+         *nfds = ms->ms_nfds;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -655,17 +780,18 @@ int ocall_sock_send_fd (int sockfd, const void * buf, unsigned int count,
+                         const unsigned int * fds, unsigned int nfds)
+ {
+     int retval = 0;
+-    ms_ocall_sock_send_fd_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_send_fd_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sock_send_fd_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+-    ms->ms_buf = COPY_TO_USER(buf, count);
++    ms->ms_buf = copy_to_user(buf, count);
+     ms->ms_count = count;
+-    ms->ms_fds = fds ? COPY_TO_USER(fds, sizeof(int) * nfds) : NULL;
++    ms->ms_fds = fds ? copy_to_user(fds, sizeof(int) * nfds) : NULL;
+     ms->ms_nfds = nfds;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_SEND_FD, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_SOCK_SEND_FD, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+@@ -673,121 +799,134 @@ int ocall_sock_setopt (int sockfd, int level, int optname,
+                        const void * optval, unsigned int optlen)
+ {
+     int retval = 0;
+-    ms_ocall_sock_setopt_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_setopt_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sock_setopt_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+     ms->ms_level = level;
+     ms->ms_optname = optname;
+-    ms->ms_optval = COPY_TO_USER(optval, optlen);
++    ms->ms_optval = copy_to_user(optval, optlen);
+     ms->ms_optlen = optlen;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_SETOPT, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_SOCK_SETOPT, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_sock_shutdown (int sockfd, int how)
+ {
+     int retval = 0;
+-    ms_ocall_sock_shutdown_t * ms;
+-    OCALLOC(ms, ms_ocall_sock_shutdown_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sock_shutdown_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_sockfd = sockfd;
+     ms->ms_how = how;
+ 
+-    retval = SGX_OCALL(OCALL_SOCK_SHUTDOWN, ms);
+-    OCALL_EXIT();
++    retval = sgx_exitless_ocall(OCALL_SOCK_SHUTDOWN, ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_gettime (unsigned long * microsec)
+ {
+     int retval = 0;
+-    ms_ocall_gettime_t * ms;
+-    OCALLOC(ms, ms_ocall_gettime_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
+-    retval = SGX_OCALL(OCALL_GETTIME, ms);
++    ms_ocall_gettime_t * ms = sgx_ocalloc(sizeof(*ms));
++
++    retval = sgx_exitless_ocall(OCALL_GETTIME, ms);
+     if (!retval)
+         *microsec = ms->ms_microsec;
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_sleep (unsigned long * microsec)
+ {
+     int retval = 0;
+-    ms_ocall_sleep_t * ms;
+-    OCALLOC(ms, ms_ocall_sleep_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
++    ms_ocall_sleep_t * ms = sgx_ocalloc(sizeof(*ms));
+     ms->ms_microsec = microsec ? *microsec : 0;
+ 
+-    retval = SGX_OCALL(OCALL_SLEEP, ms);
++    retval = sgx_ocall(OCALL_SLEEP, ms);
+     if (microsec) {
+         if (!retval)
+             *microsec = 0;
+         else if (retval == -EINTR)
+             *microsec = ms->ms_microsec;
+     }
+-    OCALL_EXIT();
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_poll (struct pollfd * fds, int nfds, uint64_t * timeout)
+ {
+     int retval = 0;
+-    ms_ocall_poll_t * ms;
+-    OCALLOC(ms, ms_ocall_poll_t *, sizeof(*ms));
++    void* frame = sgx_ocget_frame();
+ 
+-    ms->ms_fds = COPY_TO_USER(fds, sizeof(struct pollfd) * nfds);
++    ms_ocall_poll_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_fds = copy_to_user(fds, sizeof(struct pollfd) * nfds);
+     ms->ms_nfds = nfds;
+     ms->ms_timeout = timeout ? *timeout : OCALL_NO_TIMEOUT;
+ 
+-    retval = SGX_OCALL(OCALL_POLL, ms);
++    retval = sgx_exitless_ocall(OCALL_POLL, ms);
+     if (retval == -EINTR && timeout)
+         *timeout = ms->ms_timeout;
+     if (retval >= 0)
+-        COPY_FROM_USER(fds, ms->ms_fds, sizeof(struct pollfd) * nfds);
+-    OCALL_EXIT();
++        copy_from_user(fds, ms->ms_fds, sizeof(struct pollfd) * nfds);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_rename (const char * oldpath, const char * newpath)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int oldlen = oldpath ? strlen(oldpath) + 1 : 0;
+     int newlen = newpath ? strlen(newpath) + 1 : 0;
+-    ms_ocall_rename_t * ms;
+-    OCALLOC(ms, ms_ocall_rename_t *, sizeof(*ms));
+ 
+-    ms->ms_oldpath = COPY_TO_USER(oldpath, oldlen);
+-    ms->ms_newpath = COPY_TO_USER(newpath, newlen);
++    ms_ocall_rename_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_oldpath = copy_to_user(oldpath, oldlen);
++    ms->ms_newpath = copy_to_user(newpath, newlen);
++
++    retval = sgx_exitless_ocall(OCALL_RENAME, ms);
+ 
+-    retval = SGX_OCALL(OCALL_RENAME, ms);
+-    OCALL_EXIT();
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_delete (const char * pathname)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int len = pathname ? strlen(pathname) + 1 : 0;
+-    ms_ocall_delete_t * ms;
+-    OCALLOC(ms, ms_ocall_delete_t *, sizeof(*ms));
+ 
+-    ms->ms_pathname = COPY_TO_USER(pathname, len);
++    ms_ocall_delete_t * ms = sgx_ocalloc(sizeof(*ms));
++    ms->ms_pathname = copy_to_user(pathname, len);
++
++    retval = sgx_exitless_ocall(OCALL_DELETE, ms);
+ 
+-    retval = SGX_OCALL(OCALL_DELETE, ms);
+-    OCALL_EXIT();
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+ 
+ int ocall_load_debug(const char * command)
+ {
+     int retval = 0;
++    void* frame = sgx_ocget_frame();
++
+     int len = strlen(command);
+-    const char * ms = COPY_TO_USER(command, len + 1);
+-    retval = SGX_OCALL(OCALL_LOAD_DEBUG, (void *) ms);
+-    OCALL_EXIT();
++    const char * ms = copy_to_user(command, len + 1);
++    retval = sgx_exitless_ocall(OCALL_LOAD_DEBUG, (void *) ms);
++
++    sgx_ocfree_frame(frame);
+     return retval;
+ }
+diff --git a/Pal/src/host/Linux-SGX/enclave_rpcqueue.c b/Pal/src/host/Linux-SGX/enclave_rpcqueue.c
+new file mode 100644
+index 0000000000..0316bd8474
+--- /dev/null
++++ b/Pal/src/host/Linux-SGX/enclave_rpcqueue.c
+@@ -0,0 +1,57 @@
++#include <assert.h>
++#include "rpcqueue.h"
++
++void rpc_spin_lock(struct atomic_int* p) {
++    while (atomic_cmpxchg(p, SPIN_UNLOCKED, SPIN_LOCKED)) {
++        while (atomic_read(p) == SPIN_LOCKED)
++            cpu_relax();
++    }
++}
++
++/* returns 0 if acquired lock; 1 if timed out (counted as # of iterations) */
++int rpc_spin_lock_timeout(struct atomic_int* p, uint64_t iterations) {
++    while (atomic_cmpxchg(p, SPIN_UNLOCKED, SPIN_LOCKED)) {
++        while (atomic_read(p) == SPIN_LOCKED) {
++            if (iterations-- == 0)  return 1;
++            cpu_relax();
++        }
++    }
++    return 0;
++}
++
++void rpc_spin_unlock(struct atomic_int* p) {
++    atomic_set(p, SPIN_UNLOCKED);
++}
++
++rpc_request_t* rpc_enqueue(rpc_queue_t* q, rpc_request_t* req) {
++    rpc_spin_lock(&q->lock);
++
++    if (q->rear - q->front >= RPC_QUEUE_SIZE) {
++        rpc_spin_unlock(&q->lock);
++        return NULL;
++    }
++
++    assert(q->q[q->rear % RPC_QUEUE_SIZE] == NULL);
++    q->q[q->rear % RPC_QUEUE_SIZE] = req;
++    q->rear++;
++
++    rpc_spin_unlock(&q->lock);
++    return req;
++}
++
++rpc_request_t* rpc_dequeue(rpc_queue_t* q) {
++    rpc_spin_lock(&q->lock);
++
++    if (q->front == q->rear) {
++        rpc_spin_unlock(&q->lock);
++        return NULL;
++    }
++
++    assert(q->q[q->front % RPC_QUEUE_SIZE] != NULL);
++    rpc_request_t* req = q->q[q->front % RPC_QUEUE_SIZE];
++    q->q[q->front % RPC_QUEUE_SIZE] = NULL;
++    q->front++;
++
++    rpc_spin_unlock(&q->lock);
++    return req;
++}
+diff --git a/Pal/src/host/Linux-SGX/rpcqueue.h b/Pal/src/host/Linux-SGX/rpcqueue.h
+new file mode 100644
+index 0000000000..86c4f97bcd
+--- /dev/null
++++ b/Pal/src/host/Linux-SGX/rpcqueue.h
+@@ -0,0 +1,82 @@
++/*
++ * RPC threads are helper threads that run in untrusted mode alongside
++ * enclave threads. RPC threads issue system calls on behalf of enclave
++ * threads. This allows "exitless" design when app threads never leave
++ * the enclave (except for a few syscalls where there is no benefit).
++ *
++ * "Exitless" design alleviates expensive OCALLs/ECALLs. This was first
++ * proposed by SCONE (by Arnautov et al at OSDI 2016) and by Eleos
++ * (by Orenbach et al at EuroSys 2017).
++ *
++ * Brief description: user must specify "sgx.rpc_thread_num = 2" in manifest
++ * to create two RPC threads. If user specifies "0" or omits this directive,
++ * then no RPC threads are created and all syscalls perform an enclave exit
++ * (as in previous versions of Graphene-SGX).
++ *
++ * All enclave and RPC threads work on a single shared RPC queue (global
++ * variable `g_rpc_queue`). To issue syscall, enclave thread enqueues syscall
++ * request in the queue and spins waiting for result. RPC threads spin
++ * waiting for syscall requests; when request comes, first lucky RPC thread
++ * grabs request, issues syscall to OS, and notifies enclave thread by
++ * releasing the request lock. RPC queue is implemented as a FIFO ring buffer
++ * with one global lock.
++ *
++ * RPC queue can have up to RPC_QUEUE_SIZE requests simultaneously. All
++ * requests are allocated on the untrusted stack of the enclave thread;
++ * enclave thread owns its requests and pops them off stack when done with
++ * the system call. After enqueuing the request, enclave thread first spins
++ * for some time in hope the system call returns immediately (fast path),
++ * then sleeps waiting on futex (slow path, useful for blocking syscalls).
++ *
++ * NOTE: number of created RPC threads must match max number of simultaneous
++ * enclave threads. If there are more RPC threads, CPU time is wasted. If there
++ * are less, some enclave threads may starve, especially if there are many
++ * blocking syscalls by other enclave threads.
++ *
++ * Prototype code was written by Meni Orenbach and adapted to Graphene-SGX
++ * by Dmitrii Kuvaiskii.
++ */
++#ifndef QUEUE_H_
++#define QUEUE_H_
++
++#include <stdint.h>
++#include <stddef.h>
++#include <atomic.h>
++
++#define RPC_QUEUE_SIZE 1024         /* max # of requests in RPC queue */
++#define MAX_RPC_THREADS 64          /* max number of RPC threads */
++#define RPC_SPIN_LOCK_TIMEOUT 4096  /* # of iterations to spin before sleeping */
++
++#define SPIN_UNLOCKED           0
++#define SPIN_LOCKED             1
++
++/* RPC requests use spinlocks + futexes, based on Futexes are Tricky;
++ * Note that ordering is important due to atomic-dec in unlock logic */
++#define REQ_UNLOCKED            SPIN_UNLOCKED
++#define REQ_LOCKED_NO_WAITERS   SPIN_LOCKED
++#define REQ_LOCKED_WITH_WAITERS (SPIN_LOCKED+1)
++
++typedef struct {
++    int result;
++    int ocall_index;
++    void* buffer;
++    struct atomic_int lock;  /* can be REQ_UNLOCKED/LOCKED/WAITERS */
++} rpc_request_t;
++
++typedef struct rpc_queue {
++    uint64_t front, rear;
++    rpc_request_t* q[RPC_QUEUE_SIZE]; /* queue of syscall requests */
++    int rpc_threads[MAX_RPC_THREADS]; /* RPC threads (thread IDs) */
++    volatile size_t rpc_threads_num;  /* number of RPC threads */
++    struct atomic_int lock;           /* global lock for enclave and RPC threads */
++} rpc_queue_t;
++
++extern rpc_queue_t* g_rpc_queue;  /* global RPC queue */
++
++void rpc_spin_lock(struct atomic_int* p);
++int  rpc_spin_lock_timeout(struct atomic_int* p, uint64_t iterations);
++void rpc_spin_unlock(struct atomic_int* p);
++rpc_request_t* rpc_enqueue(rpc_queue_t* q, rpc_request_t* req);
++rpc_request_t* rpc_dequeue(rpc_queue_t* q);
++
++#endif /* QUEUE_H_ */
+diff --git a/Pal/src/host/Linux-SGX/sgx_api.h b/Pal/src/host/Linux-SGX/sgx_api.h
+index 502c7f0bbc..efaf79ab84 100644
+--- a/Pal/src/host/Linux-SGX/sgx_api.h
++++ b/Pal/src/host/Linux-SGX/sgx_api.h
+@@ -24,8 +24,9 @@
+ 
+ int sgx_ocall (unsigned long code, void * ms);
+ 
++void * sgx_ocget_frame (void);
+ void * sgx_ocalloc (uint64_t size);
+-void sgx_ocfree (void);
++void sgx_ocfree_frame (void * frame);
+ 
+ bool sgx_is_within_enclave (const void * addr, uint64_t size);
+ 
+diff --git a/Pal/src/host/Linux-SGX/sgx_enclave.c b/Pal/src/host/Linux-SGX/sgx_enclave.c
+index f65cd86f3e..2f43adda40 100644
+--- a/Pal/src/host/Linux-SGX/sgx_enclave.c
++++ b/Pal/src/host/Linux-SGX/sgx_enclave.c
+@@ -6,6 +6,7 @@
+ #include "sgx_internal.h"
+ #include "pal_security.h"
+ #include "pal_linux_error.h"
++#include "rpcqueue.h"
+ 
+ #include <asm/mman.h>
+ #include <asm/ioctls.h>
+@@ -13,8 +14,10 @@
+ #include <linux/fs.h>
+ #include <linux/in.h>
+ #include <linux/in6.h>
++#include <linux/futex.h>
+ #include <math.h>
+ #include <asm/errno.h>
++#include <linux/signal.h>
+ 
+ #ifndef SOL_IPV6
+ # define SOL_IPV6 41
+@@ -30,6 +33,14 @@ static int sgx_ocall_exit(void* prv)
+         SGX_DBG(DBG_E, "Saturation error in exit code %d, getting rounded down to %u\n", rv, (uint8_t) rv);
+         rv = 255;
+     }
++
++    /* kill all app threads if no more enclave threads */
++    int num_enclave_threads = unmap_tcs();
++    if (num_enclave_threads <= 0) {
++        INLINE_SYSCALL(exit_group, 1, rv);
++        return 0;
++    }
++
+     INLINE_SYSCALL(exit, 1, (int)rv);
+     return 0;
+ }
+@@ -220,7 +231,7 @@ static int sgx_ocall_getdents(void * pms)
+ static int sgx_ocall_wake_thread(void * pms)
+ {
+     ODEBUG(OCALL_WAKE_THREAD, pms);
+-    return pms ? interrupt_thread(pms) : clone_thread();
++    return pms ? interrupt_thread(pms) : clone_thread(NULL);
+ }
+ 
+ int sgx_create_process (const char * uri,
+@@ -709,12 +720,82 @@ sgx_ocall_fn_t ocall_table[OCALL_NR] = {
+ 
+ #define EDEBUG(code, ms) do {} while (0)
+ 
++rpc_queue_t* g_rpc_queue = NULL; /* pointer to untrusted queue */
++
++int sigfillset(sigset_t *set);
++int sigdelset(sigset_t *set, int signo);
++int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);
++
++static void* rpc_thread_loop(void* encl) {
++    long mytid = INLINE_SYSCALL(gettid, 0);
++
++    /* this RPC thread needs current_enclave for some sgx_ocall's */
++    current_enclave = (struct pal_enclave *)encl;
++
++    /* block all signals except SIGUSR2 for RPC thread */
++    sigset_t mask;
++    sigfillset(&mask);
++    sigdelset(&mask, SIGUSR2);
++    pthread_sigmask(SIG_SETMASK, &mask, NULL);
++
++    rpc_spin_lock(&g_rpc_queue->lock);
++    g_rpc_queue->rpc_threads[g_rpc_queue->rpc_threads_num] = mytid;
++    g_rpc_queue->rpc_threads_num++;
++    rpc_spin_unlock(&g_rpc_queue->lock);
++
++    while (1) {
++        rpc_request_t* req = rpc_dequeue(g_rpc_queue);
++        if (!req) {
++            cpu_relax();
++            continue;
++        }
++
++        /* call actual function and notify awaiting enclave thread when done */
++        typedef int (*bridge_fn_t)(const void*);
++        bridge_fn_t bridge = (bridge_fn_t)(ocall_table[req->ocall_index]);
++        req->result = bridge(req->buffer);
++
++        /* this code is based on Mutex 2 from Futexes are Tricky */
++        if (!atomic_dec_and_test(&req->lock)) {
++            /* new value of lock is not REQ_UNLOCKED (0), that means
++             * old value was REQ_LOCKED_WITH_WAITERS (2) -> must wake waiters */
++            atomic_set(&req->lock, REQ_UNLOCKED);
++            int ret = INLINE_SYSCALL(futex, 6, (int*)&req->lock.counter,
++                         FUTEX_WAKE_PRIVATE, 1, NULL, NULL, 0);
++            if (ret == -1)
++                SGX_DBG(DBG_E, "RPC thread failed to wake up enclave thread\n");
++        }
++    }
++
++    /* NOTREACHED */
++    return 0;
++}
++
++static void start_rpc(size_t num_of_threads) {
++    g_rpc_queue = (rpc_queue_t*) INLINE_SYSCALL(mmap, 6, NULL, sizeof(rpc_queue_t),
++            PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
++
++    for (size_t i = 0; i < num_of_threads; i++)
++        clone_thread(rpc_thread_loop);
++
++    while (g_rpc_queue->rpc_threads_num != current_enclave->rpc_thread_num) {
++        /* wait until all RPC threads are initialized in rpc_thread_loop */
++        INLINE_SYSCALL(sched_yield, 0);
++    }
++}
++
+ int ecall_enclave_start (const char ** arguments, const char ** environments)
+ {
++    g_rpc_queue = NULL;
++
++    if (current_enclave->rpc_thread_num > 0)
++        start_rpc(current_enclave->rpc_thread_num);
++
+     ms_ecall_enclave_start_t ms;
+     ms.ms_arguments = arguments;
+     ms.ms_environments = environments;
+     ms.ms_sec_info = PAL_SEC();
++    ms.rpc_queue = g_rpc_queue;
+     EDEBUG(ECALL_ENCLAVE_START, &ms);
+     return sgx_ecall(ECALL_ENCLAVE_START, &ms);
+ }
+diff --git a/Pal/src/host/Linux-SGX/sgx_exception.c b/Pal/src/host/Linux-SGX/sgx_exception.c
+index 15ec861870..e90564b799 100644
+--- a/Pal/src/host/Linux-SGX/sgx_exception.c
++++ b/Pal/src/host/Linux-SGX/sgx_exception.c
+@@ -29,6 +29,7 @@
+ #include "ecall_types.h"
+ #include "ocall_types.h"
+ #include "sgx_internal.h"
++#include "rpcqueue.h"
+ 
+ #include <atomic.h>
+ #include <sigset.h>
+@@ -202,6 +203,11 @@ void sgx_entry_return (void);
+ static void _DkTerminateSighandler (int signum, siginfo_t * info,
+                                     struct ucontext * uc)
+ {
++    /* send dummy signal to RPC threads so they interrupt blocked syscalls */
++    if (g_rpc_queue)
++        for (size_t i = 0; i < g_rpc_queue->rpc_threads_num; i++)
++            INLINE_SYSCALL(tkill, 2, g_rpc_queue->rpc_threads[i], SIGUSR2);
++
+     unsigned long rip = uc->uc_mcontext.gregs[REG_RIP];
+ 
+ #if SGX_HAS_FSGSBASE == 0
+@@ -225,6 +231,12 @@ static void _DkTerminateSighandler (int signum, siginfo_t * info,
+ static void _DkResumeSighandler (int signum, siginfo_t * info,
+                                  struct ucontext * uc)
+ {
++    /* send dummy signal to RPC threads so they interrupt blocked syscalls;
++     * only do it on a benign SIGFPE signal (FP/div-by-zero exception) */
++    if (g_rpc_queue && signum == SIGFPE)
++        for (size_t i = 0; i < g_rpc_queue->rpc_threads_num; i++)
++            INLINE_SYSCALL(tkill, 2, g_rpc_queue->rpc_threads[i], SIGUSR2);
++
+     unsigned long rip = uc->uc_mcontext.gregs[REG_RIP];
+ 
+ #if SGX_HAS_FSGSBASE == 0
+@@ -261,6 +273,16 @@ static void _DkResumeSighandler (int signum, siginfo_t * info,
+ #endif
+ }
+ 
++static void _DkEmptySighandler (int signum, siginfo_t * info,
++                                 struct ucontext * uc)
++{
++    (void) signum;
++    (void) info;
++    (void) uc;
++
++    /* we need this handler to interrupt blocking syscalls in RPC threads */
++}
++
+ int sgx_signal_setup (void)
+ {
+     int ret, sig[4];
+@@ -278,6 +300,15 @@ int sgx_signal_setup (void)
+     if ((ret = set_sighandler(sig, 4, &_DkResumeSighandler)) < 0)
+         goto err;
+ 
++    /* SIGUSR2 is reserved for Graphene usage -- interrupting blocking syscalls
++     * in RPC threads. Note that we block SIGUSR2 in normal enclave threads;
++     * This signal is unblocked by each RPC thread explicitly. */
++    sig[0] = SIGUSR2;
++    if ((ret = set_sighandler(sig, 1, &_DkEmptySighandler)) < 0)
++        goto err;
++    if (block_signals(sig, 1) < 0)
++        goto err;
++
+     return 0;
+ err:
+     return ret;
+diff --git a/Pal/src/host/Linux-SGX/sgx_internal.h b/Pal/src/host/Linux-SGX/sgx_internal.h
+index 4f391678b5..4fcb67256d 100644
+--- a/Pal/src/host/Linux-SGX/sgx_internal.h
++++ b/Pal/src/host/Linux-SGX/sgx_internal.h
+@@ -67,6 +67,7 @@ struct pal_enclave {
+     unsigned long baseaddr;
+     unsigned long size;
+     unsigned long thread_num;
++    unsigned long rpc_thread_num;
+     unsigned long ssaframesize;
+ 
+     /* files */
+@@ -117,11 +118,11 @@ void double_async_exit (void);
+ #endif
+ 
+ int interrupt_thread (void * tcs);
+-int clone_thread (void);
++int clone_thread (void *(*start_routine)(void*));
+ 
+ void create_tcs_mapper (void * tcs_base, unsigned int thread_num);
+ void map_tcs (unsigned int tid);
+-void unmap_tcs (void);
++int unmap_tcs (void);
+ 
+ extern __thread struct pal_enclave * current_enclave;
+ 
+diff --git a/Pal/src/host/Linux-SGX/sgx_main.c b/Pal/src/host/Linux-SGX/sgx_main.c
+index 9a5a573fd5..965c8e2da9 100644
+--- a/Pal/src/host/Linux-SGX/sgx_main.c
++++ b/Pal/src/host/Linux-SGX/sgx_main.c
+@@ -7,6 +7,7 @@
+ #include "sgx_tls.h"
+ #include "sgx_enclave.h"
+ #include "debugger/sgx_gdb.h"
++#include "rpcqueue.h"
+ 
+ #include <asm/fcntl.h>
+ #include <asm/socket.h>
+@@ -283,6 +284,20 @@ int initialize_enclave (struct pal_enclave * enclave)
+         return -EINVAL;
+     }
+ 
++    /* Reading sgx.rpc_thread_num from manifest */
++    if (get_config(enclave->config, "sgx.rpc_thread_num", cfgbuf, CONFIG_MAX) > 0)
++        enclave->rpc_thread_num = parse_int(cfgbuf);
++
++    if (enclave->rpc_thread_num > MAX_RPC_THREADS) {
++        SGX_DBG(DBG_E, "Too many RPC threads specified\n");
++        return -EINVAL;
++    }
++
++    if (enclave->rpc_thread_num && enclave->thread_num > RPC_QUEUE_SIZE) {
++        SGX_DBG(DBG_E, "Too many threads for exitless feature (more than capacity of RPC queue)\n");
++        return -EINVAL;
++    }
++
+     /* Reading sgx.static_address from manifest */
+     if (get_config(enclave->config, "sgx.static_address", cfgbuf, CONFIG_MAX) > 0 &&
+         cfgbuf[0] == '1')
+diff --git a/Pal/src/host/Linux-SGX/sgx_rpcqueue.c b/Pal/src/host/Linux-SGX/sgx_rpcqueue.c
+new file mode 100644
+index 0000000000..28f4043200
+--- /dev/null
++++ b/Pal/src/host/Linux-SGX/sgx_rpcqueue.c
+@@ -0,0 +1,4 @@
++#include "rpcqueue.h"
++
++/* duplicates functionality outside of enclave */
++#include "enclave_rpcqueue.c"
+diff --git a/Pal/src/host/Linux-SGX/sgx_thread.c b/Pal/src/host/Linux-SGX/sgx_thread.c
+index e17ae99b14..261544f378 100644
+--- a/Pal/src/host/Linux-SGX/sgx_thread.c
++++ b/Pal/src/host/Linux-SGX/sgx_thread.c
+@@ -12,6 +12,7 @@
+ 
+ #include "sgx_enclave.h"
+ #include "debugger/sgx_gdb.h"
++#include "rpcqueue.h"
+ 
+ __thread struct pal_enclave * current_enclave;
+ __thread sgx_arch_tcs_t * current_tcs;
+@@ -48,17 +49,27 @@ void map_tcs (unsigned int tid)
+         }
+ }
+ 
+-void unmap_tcs (void)
++int unmap_tcs (void)
+ {
+     int index = current_tcs - enclave_tcs;
+     struct thread_map * map = &enclave_thread_map[index];
+     if (index >= enclave_thread_num)
+-        return;
++        return 0;
+     SGX_DBG(DBG_I, "unmap TCS at 0x%08lx\n", map->tcs);
+     current_tcs = NULL;
+     ((struct enclave_dbginfo *) DBGINFO_ADDR)->thread_tids[index] = 0;
+     map->tid = 0;
+     map->tcs = NULL;
++
++    /* return number of live enclave threads */
++    static struct atomic_int exclusion = { .counter = 0 };
++    rpc_spin_lock(&exclusion);
++    int res = 0;
++    for (int i = 0; i < enclave_thread_num; i++)
++        if (enclave_thread_map[i].tid)
++            res++;
++    rpc_spin_unlock(&exclusion);
++    return res;
+ }
+ 
+ static void * thread_start (void * arg)
+@@ -77,10 +88,14 @@ static void * thread_start (void * arg)
+     return NULL;
+ }
+ 
+-int clone_thread (void)
++int clone_thread (void *(*start_routine)(void*))
+ {
+     pthread_t thread;
+-    return pthread_create(&thread, NULL, thread_start, current_enclave);
++
++    if (!start_routine)
++        start_routine = thread_start;
++
++    return pthread_create(&thread, NULL, start_routine, current_enclave);
+ }
+ 
+ int interrupt_thread (void * tcs)
diff --git a/graphene_patches.patch b/graphene_patches.patch
new file mode 100644
index 0000000..bc49076
--- /dev/null
+++ b/graphene_patches.patch
@@ -0,0 +1,361 @@
+diff --git a/LibOS/shim/include/shim_handle.h b/LibOS/shim/include/shim_handle.h
+index 7065a4a..a95343b 100644
+--- a/LibOS/shim/include/shim_handle.h
++++ b/LibOS/shim/include/shim_handle.h
+@@ -383,8 +383,8 @@ struct shim_fd_handle {
+     struct shim_handle * handle;
+ };
+ 
+-#define MAX_MAX_FDS         (65536)
+-#define DEFAULT_MAX_FDS     (1024)
++#define MAX_MAX_FDS         (65536) /*(512) - only via ulimit; otherwise prob. if compared to lwIP fd inside app*/
++#define DEFAULT_MAX_FDS     (1024) /*(512) - cf. above */
+ extern unsigned int max_fds;
+ 
+ struct shim_handle_map {
+diff --git a/LibOS/shim/include/shim_table.h b/LibOS/shim/include/shim_table.h
+index 8338132..d4e6fbd 100644
+--- a/LibOS/shim/include/shim_table.h
++++ b/LibOS/shim/include/shim_table.h
+@@ -643,6 +643,10 @@ int shim_setregid (gid_t rgid, gid_t egid);
+ int shim_getgroups (int gidsetsize, gid_t * grouplist);
+ int shim_setgroups (int gidsetsize, gid_t * grouplist);
+ int shim_setresuid (uid_t ruid, uid_t euid, uid_t suid);
++/* custom start */
++int shim_do_setresuid (uid_t ruid, uid_t euid, uid_t suid);
++int shim_do_setresgid (gid_t rgid, gid_t egid, gid_t sgid);
++/* custom end */
+ int shim_getresuid (uid_t * ruid, uid_t * euid, uid_t * suid);
+ int shim_setresgid (gid_t rgid, gid_t egid, gid_t sgid);
+ int shim_getresgid (gid_t * rgid, gid_t * egid, gid_t * sgid);
+diff --git a/LibOS/shim/src/shim_syscalls.c b/LibOS/shim/src/shim_syscalls.c
+index 1c8ac31..15bd360 100644
+--- a/LibOS/shim/src/shim_syscalls.c
++++ b/LibOS/shim/src/shim_syscalls.c
+@@ -536,14 +536,18 @@ SHIM_SYSCALL_PASSTHROUGH (getgroups, 2, int, int, gidsetsize, gid_t *,
+ SHIM_SYSCALL_PASSTHROUGH (setgroups, 2, int, int, gidsetsize, gid_t *,
+                           grouplist)
+ 
+-SHIM_SYSCALL_PASSTHROUGH (setresuid, 3, int, uid_t, ruid, uid_t, euid, uid_t,
+-                          suid)
++//SHIM_SYSCALL_PASSTHROUGH (setresuid, 3, int, uid_t, ruid, uid_t, euid, uid_t,
++//                          suid)
++
++DEFINE_SHIM_SYSCALL (setresuid, 3, shim_do_setresuid, int, uid_t, ruid, uid_t, euid, uid_t, suid)
+ 
+ SHIM_SYSCALL_PASSTHROUGH (getresuid, 3, int, uid_t *, ruid, uid_t *, euid,
+                           uid_t *, suid)
+ 
+-SHIM_SYSCALL_PASSTHROUGH (setresgid, 3, int, gid_t, rgid, gid_t, egid, gid_t,
+-                          sgid)
++//SHIM_SYSCALL_PASSTHROUGH (setresgid, 3, int, gid_t, rgid, gid_t, egid, gid_t,
++//                          sgid)
++
++DEFINE_SHIM_SYSCALL (setresgid, 3, shim_do_setresgid, int, gid_t, rgid, gid_t, egid, gid_t, sgid)
+ 
+ SHIM_SYSCALL_PASSTHROUGH (getresgid, 3, int, gid_t *, rgid, gid_t *, egid,
+                           gid_t *, sgid)
+diff --git a/LibOS/shim/src/sys/shim_getpid.c b/LibOS/shim/src/sys/shim_getpid.c
+index 255525c..1f554cf 100644
+--- a/LibOS/shim/src/sys/shim_getpid.c
++++ b/LibOS/shim/src/sys/shim_getpid.c
+@@ -74,9 +74,30 @@ gid_t shim_do_getgid (void)
+     return cur ? cur->gid : 0;
+ }
+ 
++// custom start
++int shim_do_setresuid (uid_t ruid, uid_t euid, uid_t suid) {
++    //if (ruid != suid || ruid != -1) return -ENOSYS;
++    struct shim_thread * cur = get_cur_thread();
++    if(cur == NULL) return -1;
++    cur->euid = (uint16_t) euid;
++    // ignore ruid and suid ...
++    return 0;
++}
++
++int shim_do_setresgid (gid_t rgid, gid_t egid, gid_t sgid) {
++    //if (rgid != sgid || rgid != -1) return -ENOSYS;
++    struct shim_thread * cur = get_cur_thread();
++    if(cur == NULL) return -1;
++    cur->egid = (uint16_t) egid;
++    // ignore rgid and sgid ...
++    return 0;
++}
++// custom end
++
+ int shim_do_setuid (uid_t uid)
+ {
+     struct shim_thread * cur = get_cur_thread();
++    if (cur == NULL) return -1;
+     cur->euid = (uint16_t) uid;
+     return 0;
+ }
+diff --git a/LibOS/shim/src/sys/shim_poll.c b/LibOS/shim/src/sys/shim_poll.c
+index 9162153..f977e0f 100644
+--- a/LibOS/shim/src/sys/shim_poll.c
++++ b/LibOS/shim/src/sys/shim_poll.c
+@@ -420,7 +420,8 @@ int shim_do_poll (struct pollfd * fds, nfds_t nfds, int timeout)
+         if (polls[i].flags & RET_W)
+             fds[i].revents |= (fds[i].events & (POLLOUT|POLLWRNORM));
+         if (polls[i].flags & RET_E)
+-            fds[i].revents |= (fds[i].events & (POLLERR|POLLHUP));
++            fds[i].revents |= (POLLERR|POLLHUP);
++            // BUG #592: fds[i].revents |= (fds[i].events & (POLLERR|POLLHUP));
+ 
+         if (fds[i].revents)
+             ret++;
+diff --git a/LibOS/shim/test/apps/lmbench/lmbench-2.5 b/LibOS/shim/test/apps/lmbench/lmbench-2.5
+index 33d3db0..695ed29 160000
+--- a/LibOS/shim/test/apps/lmbench/lmbench-2.5
++++ b/LibOS/shim/test/apps/lmbench/lmbench-2.5
+@@ -1 +1 @@
+-Subproject commit 33d3db09ac06920213605cca46cf1f5a022eed80
++Subproject commit 695ed29fa2cef9640fa1316fb1d84263c060299f
+diff --git a/Pal/src/host/FreeBSD/db_events.c b/Pal/src/host/FreeBSD/db_events.c
+index cea539b..752d480 100644
+--- a/Pal/src/host/FreeBSD/db_events.c
++++ b/Pal/src/host/FreeBSD/db_events.c
+@@ -75,7 +75,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                              UMTX_OP_WAKE, 1, NULL, NULL);
+     }
+ 
+-    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+diff --git a/Pal/src/host/Linux-SGX/db_events.c b/Pal/src/host/Linux-SGX/db_events.c
+index 6e1548e..b8c29e3 100644
+--- a/Pal/src/host/Linux-SGX/db_events.c
++++ b/Pal/src/host/Linux-SGX/db_events.c
+@@ -25,6 +25,7 @@
+ 
+ #include "pal_defs.h"
+ #include "pal_linux_defs.h"
++#include "pal_linux_error.h"
+ #include "pal.h"
+ #include "pal_internal.h"
+ #include "pal_linux.h"
+@@ -67,7 +68,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                 ret = ocall_futex((int *) &event->event.signaled->counter,
+                                   FUTEX_WAKE, nwaiters, NULL);
+ 
+-                if (ret < 0)
++                if (IS_ERR(ret))
+                     atomic_set(event->event.signaled, 0);
+             }
+         }
+@@ -75,11 +76,9 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+         // Only one thread wakes up, leave unsignaled
+         ret = ocall_futex((int *) &event->event.signaled->counter,
+                           FUTEX_WAKE, 1, NULL);
+-        if (ret < 0)
+-             return ret;
+     }
+ 
+-    return ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+@@ -94,11 +93,13 @@ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+         do {
+             ret = ocall_futex((int *) &event->event.signaled->counter,
+                               FUTEX_WAIT, 0, timeout ? &waittime : NULL);
+-            if (ret < 0) {
+-                if (ret == -PAL_ERROR_TRYAGAIN)
++            if (IS_ERR(ret)) {
++                if (ERRNO(ret) == EWOULDBLOCK) {
+                     ret = 0;
+-                else
++                } else {
++                    ret = unix_to_pal_error(ERRNO(ret));
+                     break;
++                }
+             }
+         } while (event->event.isnotification &&
+                  !atomic_read(event->event.signaled));
+@@ -119,11 +120,13 @@ int _DkEventWait (PAL_HANDLE event)
+         do {
+             ret = ocall_futex((int *) &event->event.signaled->counter,
+                               FUTEX_WAIT, 0, NULL);
+-            if (ret < 0) {
+-                if (ret == -PAL_ERROR_TRYAGAIN)
++            if (IS_ERR(ret)) {
++                if (ERRNO(ret) == EWOULDBLOCK) {
+                     ret = 0;
+-                else
++                } else {
++                    ret = unix_to_pal_error(ERRNO(ret));
+                     break;
++                }
+             }
+         } while (event->event.isnotification &&
+                  !atomic_read(event->event.signaled));
+diff --git a/Pal/src/host/Linux-SGX/db_mutex.c b/Pal/src/host/Linux-SGX/db_mutex.c
+index f6c39c2..5cedac2 100644
+--- a/Pal/src/host/Linux-SGX/db_mutex.c
++++ b/Pal/src/host/Linux-SGX/db_mutex.c
+@@ -27,6 +27,7 @@
+ 
+ #include "pal_defs.h"
+ #include "pal_linux_defs.h"
++#include "pal_linux_error.h"
+ #include "pal.h"
+ #include "pal_internal.h"
+ #include "pal_linux.h"
+@@ -86,11 +87,13 @@ int _DkMutexLockTimeout (struct mutex_handle * m, uint64_t timeout)
+          */
+         ret = ocall_futex((int *) m->locked, FUTEX_WAIT, MUTEX_LOCKED, timeout == -1 ? NULL : &timeout);
+ 
+-        if (ret < 0) {
+-            if (-ret == EWOULDBLOCK) {
+-                ret = -PAL_ERROR_TRYAGAIN;
+-                atomic_dec(&m->nwaiters);
+-                goto out;
++        if (IS_ERR(ret)) {
++            if (ERRNO(ret) == EWOULDBLOCK) {
++                if (timeout != NO_TIMEOUT) {
++                    ret = -PAL_ERROR_TRYAGAIN;
++                    atomic_dec(&m->nwaiters);
++                    goto out;
++                }
+             }
+             ret = unix_to_pal_error(ERRNO(ret));
+             atomic_dec(&m->nwaiters);
+diff --git a/Pal/src/host/Linux-SGX/pal_linux.h b/Pal/src/host/Linux-SGX/pal_linux.h
+index 0e5ff29..a04a92b 100644
+--- a/Pal/src/host/Linux-SGX/pal_linux.h
++++ b/Pal/src/host/Linux-SGX/pal_linux.h
+@@ -203,11 +203,11 @@ extern struct pal_enclave_config {
+ #define DBG_P   0x10
+ #define DBG_M   0x20
+ 
+-#ifdef DEBUG
++/*#ifdef DEBUG
+ # define DBG_LEVEL (DBG_E|DBG_I|DBG_D|DBG_S)
+-#else
++#else*/
+ # define DBG_LEVEL (DBG_E)
+-#endif
++/*#endif*/
+ 
+ #ifdef IN_ENCLAVE
+ #define SGX_DBG(class, fmt...) \
+diff --git a/Pal/src/host/Linux-SGX/sgx_enclave.c b/Pal/src/host/Linux-SGX/sgx_enclave.c
+index f65cd86..ddc7373 100644
+--- a/Pal/src/host/Linux-SGX/sgx_enclave.c
++++ b/Pal/src/host/Linux-SGX/sgx_enclave.c
+@@ -239,6 +239,10 @@ static int sgx_ocall_create_process(void * pms)
+     return 0;
+ }
+ 
++/* sgx_ocall_futex return unix errno instead of PAL_ERROR
++ * because PAL_ERROR doesn't distinguish ETIMEDOUT and EAGAIN.
++ * In futex case, they needs to be distinguished.
++ */
+ static int sgx_ocall_futex(void * pms)
+ {
+     ms_ocall_futex_t * ms = (ms_ocall_futex_t *) pms;
+@@ -252,7 +256,7 @@ static int sgx_ocall_futex(void * pms)
+     }
+     ret = INLINE_SYSCALL(futex, 6, ms->ms_futex, ms->ms_op, ms->ms_val,
+                          ts, NULL, 0);
+-    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : ret;
++    return ret;
+ }
+ 
+ static int sgx_ocall_socketpair(void * pms)
+diff --git a/Pal/src/host/Linux-SGX/sgx_main.c b/Pal/src/host/Linux-SGX/sgx_main.c
+index c786c84..2ca8101 100644
+--- a/Pal/src/host/Linux-SGX/sgx_main.c
++++ b/Pal/src/host/Linux-SGX/sgx_main.c
+@@ -827,6 +827,7 @@ static int load_enclave (struct pal_enclave * enclave,
+ 
+ int main (int argc, const char ** argv, const char ** envp)
+ {
++//    struct timeval tv_begin;
+     const char * manifest_uri = NULL;
+     char * exec_uri = NULL;
+     const char * pal_loader = argv[0];
+@@ -837,6 +838,9 @@ int main (int argc, const char ** argv, const char ** envp)
+     argc--;
+     argv++;
+ 
++//    INLINE_SYSCALL(gettimeofday, 2, &tv_begin, NULL);
++//    printf("%ld\n", tv_begin.tv_sec * 1000000UL + tv_begin.tv_usec);
++
+     struct pal_enclave * enclave = malloc(sizeof(struct pal_enclave));
+     if (!enclave)
+         return -ENOMEM;
+diff --git a/Pal/src/host/Linux-SGX/signer/pal-sgx-sign b/Pal/src/host/Linux-SGX/signer/pal-sgx-sign
+index bcb35c2..81ba6e9 100755
+--- a/Pal/src/host/Linux-SGX/signer/pal-sgx-sign
++++ b/Pal/src/host/Linux-SGX/signer/pal-sgx-sign
+@@ -313,6 +313,7 @@ class MemoryArea:
+         if file:
+             loadcmds = get_loadcmds(file)
+             if loadcmds:
++                print 'loadcmds branch for ' + self.desc
+                 mapaddr = 0xffffffffffffffff
+                 mapaddr_end = 0
+                 for (offset, addr, filesize, memsize, prot) in loadcmds:
+@@ -326,6 +327,7 @@ class MemoryArea:
+                 if mapaddr > 0:
+                     self.addr = mapaddr
+             else:
++                print 'os.start branch for ' + self.desc
+                 self.size = os.stat(file).st_size
+ 
+         if self.addr is not None:
+@@ -355,10 +357,13 @@ def get_memory_areas(manifest, attr, args):
+ 
+ def populate_memory_areas(manifest, attr, areas):
+     populating = attr['enclave_size']
++    print "populating: "+str(populating)
+ 
+     for area in areas:
+         if area.addr is not None:
+             continue
++        print 'area.desc: ' + area.desc
++        print 'area.size: ' + str(area.size)
+ 
+         area.addr = populating - area.size
+         if area.addr < ENCLAVE_HEAP_MIN:
+diff --git a/Pal/src/host/Linux/db_events.c b/Pal/src/host/Linux/db_events.c
+index 42d4bad..01a15f5 100644
+--- a/Pal/src/host/Linux/db_events.c
++++ b/Pal/src/host/Linux/db_events.c
+@@ -72,7 +72,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                              NULL, NULL, 0);
+     }
+ 
+-    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+diff --git a/Pal/src/host/Linux/db_mutex.c b/Pal/src/host/Linux/db_mutex.c
+index 4e9e55e..8b0a7ac 100644
+--- a/Pal/src/host/Linux/db_mutex.c
++++ b/Pal/src/host/Linux/db_mutex.c
+@@ -130,14 +130,13 @@ int _DkMutexLockTimeout (struct mutex_handle * m, uint64_t timeout)
+                     atomic_dec(&m->nwaiters);
+                     goto out;
+                 }
+-            } else {
++            }
+ #ifdef DEBUG_MUTEX
+-                printf("futex failed (err = %d)\n", ERRNO(ret));
++            printf("futex failed (err = %d)\n", ERRNO(ret));
+ #endif
+-                ret = unix_to_pal_error(ERRNO(ret));
+-                atomic_dec(&m->nwaiters);
+-                goto out;
+-            }
++            ret = unix_to_pal_error(ERRNO(ret));
++            atomic_dec(&m->nwaiters);
++            goto out;
+         }
+     }
+ 
diff --git a/graphene_runtime_symlinks/crt1.o b/graphene_runtime_symlinks/crt1.o
new file mode 120000
index 0000000..aabb693
--- /dev/null
+++ b/graphene_runtime_symlinks/crt1.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crt1.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/crti.o b/graphene_runtime_symlinks/crti.o
new file mode 120000
index 0000000..73f270e
--- /dev/null
+++ b/graphene_runtime_symlinks/crti.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crti.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/crtn.o b/graphene_runtime_symlinks/crtn.o
new file mode 120000
index 0000000..150ac50
--- /dev/null
+++ b/graphene_runtime_symlinks/crtn.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crtn.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/ld-linux-x86-64.so.2 b/graphene_runtime_symlinks/ld-linux-x86-64.so.2
new file mode 120000
index 0000000..1ff6f8e
--- /dev/null
+++ b/graphene_runtime_symlinks/ld-linux-x86-64.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/elf/ld-linux-x86-64.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libapp_bench_onload.so b/graphene_runtime_symlinks/libapp_bench_onload.so
new file mode 120000
index 0000000..5c2c604
--- /dev/null
+++ b/graphene_runtime_symlinks/libapp_bench_onload.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libapp_bench_onload.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libapr-1.so.0 b/graphene_runtime_symlinks/libapr-1.so.0
new file mode 120000
index 0000000..71ebee0
--- /dev/null
+++ b/graphene_runtime_symlinks/libapr-1.so.0
@@ -0,0 +1 @@
+/home/encl-dev/benchmarking/httpd-2.4.18/srclib/apr/.libs/libapr-1.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libaprutil-1.so.0 b/graphene_runtime_symlinks/libaprutil-1.so.0
new file mode 120000
index 0000000..4d63a6f
--- /dev/null
+++ b/graphene_runtime_symlinks/libaprutil-1.so.0
@@ -0,0 +1 @@
+/home/encl-dev/benchmarking/httpd-2.4.18/srclib/apr-util/.libs/libaprutil-1.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libbsd.so.0 b/graphene_runtime_symlinks/libbsd.so.0
new file mode 120000
index 0000000..f85caa0
--- /dev/null
+++ b/graphene_runtime_symlinks/libbsd.so.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libbsd.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libc.so b/graphene_runtime_symlinks/libc.so
new file mode 120000
index 0000000..ddc0005
--- /dev/null
+++ b/graphene_runtime_symlinks/libc.so
@@ -0,0 +1 @@
+../LibOS/glibc-build/libc.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libc.so.6 b/graphene_runtime_symlinks/libc.so.6
new file mode 120000
index 0000000..1251dd7
--- /dev/null
+++ b/graphene_runtime_symlinks/libc.so.6
@@ -0,0 +1 @@
+../LibOS/glibc-build/libc.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcom_err.so.2 b/graphene_runtime_symlinks/libcom_err.so.2
new file mode 120000
index 0000000..3c692fe
--- /dev/null
+++ b/graphene_runtime_symlinks/libcom_err.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcom_err.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcrypt.so.1 b/graphene_runtime_symlinks/libcrypt.so.1
new file mode 120000
index 0000000..648db5b
--- /dev/null
+++ b/graphene_runtime_symlinks/libcrypt.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcrypt.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcrypto.so.1.0.0 b/graphene_runtime_symlinks/libcrypto.so.1.0.0
new file mode 120000
index 0000000..3d817f9
--- /dev/null
+++ b/graphene_runtime_symlinks/libcrypto.so.1.0.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcurl.so b/graphene_runtime_symlinks/libcurl.so
new file mode 120000
index 0000000..d6a01fb
--- /dev/null
+++ b/graphene_runtime_symlinks/libcurl.so
@@ -0,0 +1 @@
+/home/encl-dev/benchmarking/my_binary_curl/curl-curl-7_47_0/build/lib/libcurl.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libdl.so.2 b/graphene_runtime_symlinks/libdl.so.2
new file mode 120000
index 0000000..1f235e1
--- /dev/null
+++ b/graphene_runtime_symlinks/libdl.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/dlfcn/libdl.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libedit.so.2 b/graphene_runtime_symlinks/libedit.so.2
new file mode 120000
index 0000000..9c08931
--- /dev/null
+++ b/graphene_runtime_symlinks/libedit.so.2
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libedit.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libexpat.so.1 b/graphene_runtime_symlinks/libexpat.so.1
new file mode 120000
index 0000000..d774768
--- /dev/null
+++ b/graphene_runtime_symlinks/libexpat.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libexpat.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgcc_s.so.1 b/graphene_runtime_symlinks/libgcc_s.so.1
new file mode 120000
index 0000000..2e4aad4
--- /dev/null
+++ b/graphene_runtime_symlinks/libgcc_s.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libgcc_s.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgcrypt.so.20 b/graphene_runtime_symlinks/libgcrypt.so.20
new file mode 120000
index 0000000..5be3209
--- /dev/null
+++ b/graphene_runtime_symlinks/libgcrypt.so.20
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libgcrypt.so.20
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgnutls.so.30 b/graphene_runtime_symlinks/libgnutls.so.30
new file mode 120000
index 0000000..81ee7bd
--- /dev/null
+++ b/graphene_runtime_symlinks/libgnutls.so.30
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libgnutls.so.30
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgssapi_krb5.so.2 b/graphene_runtime_symlinks/libgssapi_krb5.so.2
new file mode 120000
index 0000000..7170272
--- /dev/null
+++ b/graphene_runtime_symlinks/libgssapi_krb5.so.2
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libiperf.so.0 b/graphene_runtime_symlinks/libiperf.so.0
new file mode 120000
index 0000000..b9b1284
--- /dev/null
+++ b/graphene_runtime_symlinks/libiperf.so.0
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libiperf.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libk5crypto.so.3 b/graphene_runtime_symlinks/libk5crypto.so.3
new file mode 120000
index 0000000..f76bb95
--- /dev/null
+++ b/graphene_runtime_symlinks/libk5crypto.so.3
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libk5crypto.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkeyutils.so.1 b/graphene_runtime_symlinks/libkeyutils.so.1
new file mode 120000
index 0000000..48434f3
--- /dev/null
+++ b/graphene_runtime_symlinks/libkeyutils.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libkeyutils.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkrb5.so.3 b/graphene_runtime_symlinks/libkrb5.so.3
new file mode 120000
index 0000000..cd3065b
--- /dev/null
+++ b/graphene_runtime_symlinks/libkrb5.so.3
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libkrb5.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkrb5support.so.0 b/graphene_runtime_symlinks/libkrb5support.so.0
new file mode 120000
index 0000000..9290d77
--- /dev/null
+++ b/graphene_runtime_symlinks/libkrb5support.so.0
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libkrb5support.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/liblibos.so.1 b/graphene_runtime_symlinks/liblibos.so.1
new file mode 120000
index 0000000..c40d629
--- /dev/null
+++ b/graphene_runtime_symlinks/liblibos.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/libos/liblibos.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/liblwip.so b/graphene_runtime_symlinks/liblwip.so
new file mode 120000
index 0000000..50155c0
--- /dev/null
+++ b/graphene_runtime_symlinks/liblwip.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/liblwip.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libm.so.6 b/graphene_runtime_symlinks/libm.so.6
new file mode 120000
index 0000000..bd97296
--- /dev/null
+++ b/graphene_runtime_symlinks/libm.so.6
@@ -0,0 +1 @@
+../LibOS/glibc-build/math/libm.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnsl.so.1 b/graphene_runtime_symlinks/libnsl.so.1
new file mode 120000
index 0000000..d0c6282
--- /dev/null
+++ b/graphene_runtime_symlinks/libnsl.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnsl.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_compat.so.2 b/graphene_runtime_symlinks/libnss_compat.so.2
new file mode 120000
index 0000000..71b8768
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_compat.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_compat.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_db.so.2 b/graphene_runtime_symlinks/libnss_db.so.2
new file mode 120000
index 0000000..c7dd4b6
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_db.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/nss/libnss_db.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_dns.so.2 b/graphene_runtime_symlinks/libnss_dns.so.2
new file mode 120000
index 0000000..44125e2
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_dns.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/resolv/libnss_dns.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_files.so.2 b/graphene_runtime_symlinks/libnss_files.so.2
new file mode 120000
index 0000000..6f8e598
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_files.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_files.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_nis.so.2 b/graphene_runtime_symlinks/libnss_nis.so.2
new file mode 120000
index 0000000..908d218
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_nis.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_nis.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libpcre.so.3 b/graphene_runtime_symlinks/libpcre.so.3
new file mode 120000
index 0000000..45b27dd
--- /dev/null
+++ b/graphene_runtime_symlinks/libpcre.so.3
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libpcre.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libprotobuf-c.so.1 b/graphene_runtime_symlinks/libprotobuf-c.so.1
new file mode 120000
index 0000000..08b1380
--- /dev/null
+++ b/graphene_runtime_symlinks/libprotobuf-c.so.1
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libprotobuf.so.9 b/graphene_runtime_symlinks/libprotobuf.so.9
new file mode 120000
index 0000000..c55c411
--- /dev/null
+++ b/graphene_runtime_symlinks/libprotobuf.so.9
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libprotobuf.so.9
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libpthread.so.0 b/graphene_runtime_symlinks/libpthread.so.0
new file mode 120000
index 0000000..12e82e1
--- /dev/null
+++ b/graphene_runtime_symlinks/libpthread.so.0
@@ -0,0 +1 @@
+../LibOS/glibc-build/nptl/libpthread.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libreadline.so.6 b/graphene_runtime_symlinks/libreadline.so.6
new file mode 120000
index 0000000..768b9cb
--- /dev/null
+++ b/graphene_runtime_symlinks/libreadline.so.6
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libreadline.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libresolv.so.2 b/graphene_runtime_symlinks/libresolv.so.2
new file mode 120000
index 0000000..b9b0b53
--- /dev/null
+++ b/graphene_runtime_symlinks/libresolv.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/resolv/libresolv.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/librt.so.1 b/graphene_runtime_symlinks/librt.so.1
new file mode 120000
index 0000000..2d42a77
--- /dev/null
+++ b/graphene_runtime_symlinks/librt.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/rt/librt.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libselinux.so.1 b/graphene_runtime_symlinks/libselinux.so.1
new file mode 120000
index 0000000..4bfd214
--- /dev/null
+++ b/graphene_runtime_symlinks/libselinux.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libselinux.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so b/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so
new file mode 120000
index 0000000..600d16d
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_mbench_ossl_double_tunnel_netif.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_onload.so b/graphene_runtime_symlinks/libseng_ossl_double_onload.so
new file mode 120000
index 0000000..5e1b1d2
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_onload.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_onload.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so b/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so
new file mode 120000
index 0000000..d6909f4
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_onload_finegrained_mbench.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so b/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so
new file mode 120000
index 0000000..620fb4c
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_tunnel_netif.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libsgx_uae_service.so b/graphene_runtime_symlinks/libsgx_uae_service.so
new file mode 120000
index 0000000..f671e69
--- /dev/null
+++ b/graphene_runtime_symlinks/libsgx_uae_service.so
@@ -0,0 +1 @@
+/usr/lib/libsgx_uae_service.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libssl.so.1.0.0 b/graphene_runtime_symlinks/libssl.so.1.0.0
new file mode 120000
index 0000000..f5d9aa3
--- /dev/null
+++ b/graphene_runtime_symlinks/libssl.so.1.0.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libstdc++.so.6 b/graphene_runtime_symlinks/libstdc++.so.6
new file mode 120000
index 0000000..3ac50bb
--- /dev/null
+++ b/graphene_runtime_symlinks/libstdc++.so.6
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libstdc++.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libthread_db.so.1 b/graphene_runtime_symlinks/libthread_db.so.1
new file mode 120000
index 0000000..b25a306
--- /dev/null
+++ b/graphene_runtime_symlinks/libthread_db.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/nptl_db/libthread_db.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libtinfo.so.5 b/graphene_runtime_symlinks/libtinfo.so.5
new file mode 120000
index 0000000..c4803c3
--- /dev/null
+++ b/graphene_runtime_symlinks/libtinfo.so.5
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libtinfo.so.5
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libutil.so.1 b/graphene_runtime_symlinks/libutil.so.1
new file mode 120000
index 0000000..c819eda
--- /dev/null
+++ b/graphene_runtime_symlinks/libutil.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/login/libutil.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libz.so.1 b/graphene_runtime_symlinks/libz.so.1
new file mode 120000
index 0000000..c801c65
--- /dev/null
+++ b/graphene_runtime_symlinks/libz.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libz.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/pal_gdb-Linux-SGX b/graphene_runtime_symlinks/pal_gdb-Linux-SGX
new file mode 120000
index 0000000..36a8bea
--- /dev/null
+++ b/graphene_runtime_symlinks/pal_gdb-Linux-SGX
@@ -0,0 +1 @@
+../Pal/src/host/Linux-SGX/debugger/gdb
\ No newline at end of file
diff --git a/ias-ra.c b/ias-ra.c
index 70af519..9d56431 100644
--- a/ias-ra.c
+++ b/ias-ra.c
@@ -16,6 +16,8 @@
 #include "ra-attester.h"
 #include "ias-ra.h"
 
+//#define DEBUG
+
 struct buffer_and_size {
     char* data;
     size_t len;
@@ -72,7 +74,8 @@ void extract_certificates_from_response_header
 )
 {
     // Locate x-iasreport-signature HTTP header field in the response.
-    const char response_header_name[] = "x-iasreport-signing-certificate: ";
+    const char response_header_name[] = "X-IASReport-Signing-Certificate: ";
+    //const char response_header_name[] = "x-iasreport-signing-certificate: ";
     char *field_begin = memmem(header,
                                header_len,
                                response_header_name,
@@ -144,12 +147,18 @@ void parse_response_header
     uint32_t* signature_size
 )
 {
-    const char sig_tag[] = "x-iasreport-signature: ";
+    const char sig_tag[] = "X-IASReport-Signature: ";
+    //const char sig_tag[] = "x-iasreport-signature: ";
     char* sig_begin = memmem((const char*) header,
                              header_len,
                              sig_tag,
                              strlen(sig_tag));
-    assert(sig_begin != NULL);
+    /* This one has failed sometimes in the past, which results in a freeze. So call exit(1) instead */
+    //assert(sig_begin != NULL);
+    if (sig_begin == NULL) {
+        fprintf(stderr, "error in ias-ra.c:154@parse_responde_header: `sig_begin != NULL' failed\n");
+        exit(1);
+    } 
     sig_begin += strlen(sig_tag);
     char* sig_end = memmem(sig_begin,
                            header_len - (sig_begin - header),
@@ -182,31 +191,67 @@ void obtain_attestation_verification_report
 
     curl = curl_easy_init();
     if(curl) {
-        // curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
+#ifdef DEBUG
+        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
+#endif
         curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
         char url[512];
-        ret = snprintf(url, sizeof(url), "https://%s/attestation/sgx/v2/report",
+        //ret = snprintf(url, sizeof(url), "https://%s/attestation/sgx/v2/report",
+        // 05.03.19
+        //ret = snprintf(url, sizeof(url), "https://%s/attestation/sgx/v3/report",
+        //                   opts->ias_server);
+        // 10.07.19
+        ret = snprintf(url, sizeof(url), "https://%s/sgx/dev/attestation/v3/report",
                            opts->ias_server);
         assert(ret < (int) sizeof(url));
-        curl_easy_setopt(curl, CURLOPT_URL, url);
-        curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
-        curl_easy_setopt(curl, CURLOPT_SSLCERT, opts->ias_cert_file);
-        curl_easy_setopt(curl, CURLOPT_SSLKEY, opts->ias_key_file);
-        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
-        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
+        ret = curl_easy_setopt(curl, CURLOPT_URL, url);
+        assert(ret == CURLE_OK);
+//        ret = curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
+//        assert(ret == CURLE_OK);
+//        ret = curl_easy_setopt(curl, CURLOPT_SSLCERT, opts->ias_cert_file);
+//        assert(ret == CURLE_OK);
+//        ret = curl_easy_setopt(curl, CURLOPT_SSLKEY, opts->ias_key_file);
+//        assert(ret == CURLE_OK);
+	//printf("Setting password\n");
+//        ret = curl_easy_setopt(curl, CURLOPT_KEYPASSWD, "XXX");
+//        assert(ret == CURLE_OK);
+	//printf("done\n");
+        ret = curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
+        assert(ret == CURLE_OK);
+        ret = curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
+        assert(ret == CURLE_OK);
     
         struct curl_slist *headers = NULL;
         headers = curl_slist_append(headers, "Content-Type: application/json");
 
+        // new client authentication method
+        headers = curl_slist_append(headers, "Ocp-Apim-Subscription-Key: YYY");
+
         const char json_template[] = "{\"isvEnclaveQuote\":\"%s\"}";
         unsigned char quote_base64[quote_size * 2];
         char json[quote_size * 2];
 
+        memset(quote_base64, 0, sizeof(quote_base64));
+        memset(json, 0, sizeof(json));
+
         ret = EVP_EncodeBlock(quote_base64, (unsigned char*) quote, quote_size);
          // +1 since EVP_EncodeBlock() adds \0 to the output.
         assert((size_t) ret + 1 <= sizeof(quote_base64));
 
         snprintf(json, sizeof(json), json_template, quote_base64);
+
+#ifdef DEBUG
+        printf("Going to send following header:\n%s\n", headers->data);
+        printf("%s\n", headers->next->data);
+        printf("Going to send following json body:\n%s\n", json);
+
+        // == 1510 which is the shown Content-Length
+        printf("json body strlen: %ld\n", strlen(json));
+        // > 2k
+        printf("sizeof: %ld\n", sizeof(json));
+        printf("other stuff: %ld\n", strlen("{\"isvEnclaveQuote\":\"\"}"));
+        fflush(stdout);
+#endif
     
         curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json);
@@ -225,8 +270,10 @@ void obtain_attestation_verification_report
             printf("curl_easy_perform= %d\n", res);
         }
         
-        /* printf("%s", header.data); */
-        /* printf("body= %s", body.data); */
+#ifdef DEBUG
+        printf("%s", header.data);
+        printf("body= %s", body.data);
+#endif
 
         parse_response_header(header.data, header.len,
                               attn_report->ias_report_signature,
diff --git a/mbedtls-client.patch b/mbedtls-client.patch
index 3b10d50..a0ad640 100644
--- a/mbedtls-client.patch
+++ b/mbedtls-client.patch
@@ -7,13 +7,14 @@ index fa70431..a580d22 100644
  #include <string.h>
  
 -#define SERVER_PORT "4433"
+-#define SERVER_NAME "localhost"
 +#include <sgx_quote.h>
 +
 +#include "ra.h"
 +#include "ra-challenger.h"
 +
-+#define SERVER_PORT "11111"
- #define SERVER_NAME "localhost"
++#define SERVER_PORT "12345"
++#define SERVER_NAME "111.222.111.222"
  #define GET_REQUEST "GET / HTTP/1.0\r\n\r\n"
  
 -#define DEBUG_LEVEL 1
diff --git a/mbedtls-ra-attester.c b/mbedtls-ra-attester.c
index 679bfed..b24d182 100644
--- a/mbedtls-ra-attester.c
+++ b/mbedtls-ra-attester.c
@@ -22,6 +22,10 @@
 #include "ra_private.h"
 #include "mbedtls-ra-attester.h"
 
+#include <sys/time.h>
+
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
 static const size_t SHA256_DIGEST_SIZE = 32;
 
 static
@@ -70,9 +74,10 @@ void generate_x509
     mbedtls_ctr_drbg_init( &ctr_drbg );
     
     const char *pers = "crt example app";
-    assert(0 == mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
+    int r = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                                        (const unsigned char *) pers,
-                                       strlen( pers ) ));
+                                       strlen( pers ) );
+    assert ( r == 0 );
 
     int ret;
     mbedtls_x509write_crt_init(&writecrt);
@@ -174,8 +179,111 @@ void create_x509
 
     do_remote_attestation(&report_data, opts, &attestation_report);
 
+    /* TODO:    the protobuf-based communication is NOT SECURE AT ALL
+     *
+     * CORRECTION:
+     *      1. the target_info is used by EREPORT to sign the report, s.t. that
+     *          the target enclave can check that the report was indeed created
+     *          by EREPORT with target_info matching the checking enclave
+     *
+     *      2. EREPORT's RCX is the address to the userdata AND the report
+     *          contains a MAC (!), s.t. it is NOT POSSIBLE for the attacker to
+     *          replace the userdata w/o failing the report integrity checks
+     *          done by the quoting enclave
+     *
+     *      ===> attacker will not be able to mix-and-match Client Enclave
+     *          measurement part of EREPORT with its own public-key for privilege
+     *          escalation hijacking;
+     *
+     *      ===> though might still DoS the connection, hijack the connection
+     *          with own measurements / keys, or that of an older/other LEAKED
+     *          client enclave instance, and eavesdrop at the connection
+     *
+     *          ALSO: unsure whether other attacks are still possible in this
+     *          scenario
+     *
+     *      --> attacker could also privilege-drop the client enclave w/o complete
+     *          DoS by replacing the report with an other valid report including
+     *          the public key of the client enclave;
+     *
+     *          BUT: by checking report data of IAS against own EREPORT result,
+     *          the client would be able to detect such manipulations;
+     *          also it would be just another kind of partial DoS attack which
+     *          we anyway keep out of the threat model
+     *
+     *      Keeping the private key only in the client enclave and using certificate pinning
+     *      w.r.t. the middlebox certificate prevents eavesdropping attacks on the connection
+     *      between Client Enclave and Middlbox Server.
+     *
+     *      HOWEVER:    the malicious host can masquerade successfully as client enclave when
+     *          connecting to the Middlebox Server, because as long as the connection between
+     *          Client Enclave and Quoting Enclave is NOT SECURED via LOCAL ATTESTATION + secret
+     *          exchange,
+     *          the attacker is able to intercept the Report during Quote Request, replace the
+     *          public-key with its own one, intercept the resulting Quote, submit it to IAS
+     *          and then create a valid certificate with the IAS report verifying the measurements
+     *          of the client enclave bound to the attacker's own private-public key pair.
+     *
+     *          => The attacker can then successfully connect to the Middlebox Server and thereby
+     *          gain the network privileges of the client enclave.
+     *
+     *          The root of the problem is the missing authentication of the Quoting Encalve
+     *          in the NON-SDK Protobuf-based Quote creation process.
+     *
+     *      Note that afterwards the attacker could still tamper with the client certificate on
+     *      the fly, bcs for TLS <= 1.2 the certificate is sent in plaintext, BUT IAS report
+     *      manipulation can be detected via the IAS report signature check,
+     *      and IAS report replacement will NOT help, bcs:
+     *          -> the attacker doesn't know the client private key, so cannot eavesdrop
+     *          -> IAS with attacker's public key can only have the enclave measurements of
+     *              an ATTACKER CONTROLLED enclave, so no privilege escalation possible
+     *
+     *      CAUTION/WARNING:    confused deputy attacks still possible; mis-progammed enclaves
+     *              might leak their reports or make connections on behalf of an attacker which
+     *              could lead to classical privilege escalation attacks via confused deputies
+     *              as for instance in Android
+     *          -> use existing approaches to check statically that EREPORT data is not leaked
+     *          -> adopt existing ideas to find a way of handling confused deputy problem;
+     *              (PROBLEM: no secure I/O via SGX, which TZ can provide; hacky SMM approach?
+     *                  but then VT-d/IOMMU can again be ugly; lightweight(!) Hypervisor support?)
+     *
+     *
+     *      ==> solution will require Local Attestation-based secure connection between client
+     *          enclave and quoting enclave either now, or when integrating it into Graphene /
+     *          library layer
+     *
+     *      Notes:  Graphene already has some Local Attestation code for Graphene<->Graphene
+     *              bootstrapping;
+     *              Quoting Enclave MUST HAVE some kind of Local Attestation / secure channel
+     *              API used by the SDK, bcs otherwise I cannot see how such an attack would
+     *              be prevented.
+     */
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     generate_x509(cert, key, &attestation_report);
-    
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif 
+
+
     /* printf_sgx("attestation_report.ias_report=\n"); */
     /* printf_sgx("%.s", attestation_report.ias_report_len, attestation_report.ias_report); */
 }
@@ -188,6 +296,16 @@ void mbedtls_create_key_and_x509
     const struct ra_tls_options* opts
 )
 {
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_seed = 1;
+        struct timeval listen_tv_start_seed , listen_tv_end_seed ;
+        if( gettimeofday(&listen_tv_start_seed , NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_seed  = 0;
+        }
+#endif
     int ret;
 
     mbedtls_ctr_drbg_context ctr_drbg;
@@ -196,21 +314,57 @@ void mbedtls_create_key_and_x509
     mbedtls_entropy_context entropy;
     mbedtls_entropy_init( &entropy );
 
-    const char* pers = "deadbeef";
-    ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
-                                (const unsigned char *) pers,
-                                strlen(pers));
+    //const char* pers = "deadbeef";
+    ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0);
+//                                (const unsigned char *) pers,
+//                                strlen(pers));
     assert(ret == 0);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_seed == 1 ) {
+            if ( gettimeofday(&listen_tv_end_seed, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_seed.tv_sec - listen_tv_start_seed.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_seed.tv_usec - listen_tv_start_seed.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif
 
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     mbedtls_pk_setup(key, mbedtls_pk_info_from_type(MBEDTLS_PK_RSA));
 
     mbedtls_rsa_init((mbedtls_rsa_context*)key->pk_ctx,
                      MBEDTLS_RSA_PKCS_V15, 0);
-    
+
     ret = mbedtls_rsa_gen_key((mbedtls_rsa_context*)key->pk_ctx,
                               mbedtls_ctr_drbg_random, &ctr_drbg, 2048, 65537);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif
+
     assert(ret == 0);
-    
+
     create_x509(key, cert, opts);
 }
 
diff --git a/mbedtls-ra-challenger.c b/mbedtls-ra-challenger.c
index ecee76a..d225ce2 100644
--- a/mbedtls-ra-challenger.c
+++ b/mbedtls-ra-challenger.c
@@ -24,7 +24,7 @@ extern unsigned char ias_sign_ca_cert_der[];
 extern unsigned int ias_sign_ca_cert_der_len;
 
 static
-void extract_x509_extension
+int extract_x509_extension
 (
     uint8_t* ext,
     int ext_len,
@@ -38,60 +38,78 @@ void extract_x509_extension
     uint8_t* base64_data;
     size_t base64_data_len;
     
-    find_oid(ext, ext_len, oid, oid_len,
-             &base64_data, &base64_data_len);
+    if (find_oid(ext, ext_len, oid, oid_len,
+                 &base64_data, &base64_data_len) != 0) {
+        return 1;
+    }
     
     assert(base64_data != NULL);
-    assert(base64_data_len <= data_max_len);
+    
+    if(!(base64_data_len <= data_max_len)) {
+        return 1;
+    }
 
     size_t out_len;
-    int ret;
-    ret = mbedtls_base64_decode(data,
+    if (mbedtls_base64_decode(data,
                                 data_max_len,
                                 &out_len,
                                 base64_data,
-                                base64_data_len);
+                              base64_data_len) != 0) {
+        return 1;
+    }
 
-    assert(ret == 0);
-    assert(out_len <= UINT32_MAX);
+    if (!(out_len <= UINT32_MAX)) {
+        return 1;
+    }
     *data_len = (uint32_t) out_len;
+    return 0;
 }
 
 /* Extract extensions from X509 and decode base64. */
 static
-void extract_x509_extensions
+int extract_x509_extensions
 (
     uint8_t* ext,
     int ext_len,
     attestation_verification_report_t* attn_report
 )
 {
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_response_body_oid, ias_oid_len,
                            attn_report->ias_report,
                            &attn_report->ias_report_len,
-                           sizeof(attn_report->ias_report));
+                               sizeof(attn_report->ias_report)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_root_cert_oid, ias_oid_len,
                            attn_report->ias_sign_ca_cert,
                            &attn_report->ias_sign_ca_cert_len,
-                           sizeof(attn_report->ias_sign_ca_cert));
+                               sizeof(attn_report->ias_sign_ca_cert)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_leaf_cert_oid, ias_oid_len,
                            attn_report->ias_sign_cert,
                            &attn_report->ias_sign_cert_len,
-                           sizeof(attn_report->ias_sign_cert));
+                               sizeof(attn_report->ias_sign_cert)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_report_signature_oid, ias_oid_len,
                            attn_report->ias_report_signature,
                            &attn_report->ias_report_signature_len,
-                           sizeof(attn_report->ias_report_signature));
+                               sizeof(attn_report->ias_report_signature)) != 0) {
+        return 1;
+    }
+    
+    return 0;
 }
 
-void get_quote_from_report(const uint8_t* report /* in */,
+int get_quote_from_report(const uint8_t* report /* in */,
                            const int report_len  /* in */,
                            sgx_quote_t* quote)
 {
@@ -99,23 +117,35 @@ void get_quote_from_report(const uint8_t* report /* in */,
 
     const char* json_string = "\"isvEnclaveQuoteBody\":\"";
     char* p_begin = strstr((const char*) report, json_string);
-    assert(p_begin != NULL);
+    if (p_begin == NULL) {
+        return 1;
+    }
     p_begin += strlen(json_string);
     const char* p_end = strchr(p_begin, '"');
-    assert(p_end != NULL);
+    if (p_end == NULL) {
+        return 1;
+    }
 
     const int quote_base64_len = p_end - p_begin;
     uint8_t* quote_bin = malloc(quote_base64_len);
+    
+    if (quote_bin == NULL) {
+        return 1;
+    }
+    
     size_t quote_bin_len = quote_base64_len;
 
-    mbedtls_base64_decode(quote_bin, quote_base64_len,
-                          &quote_bin_len,
-                          (unsigned char*) p_begin, quote_base64_len);
+    if (mbedtls_base64_decode(quote_bin, quote_base64_len,
+                              &quote_bin_len, (unsigned char*) p_begin, quote_base64_len) != 0
+        || !(quote_bin_len <= sizeof(sgx_quote_t))) {
+        free (quote_bin);
+        return 1;
+    }
 
-    assert(quote_bin_len <= sizeof(sgx_quote_t));
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+    return 0;
 }
 
 static
@@ -233,6 +263,10 @@ int verify_ias_report_signature
                                    MBEDTLS_MD_SHA256, 0,
                                    sha256,
                                    attn_report->ias_report_signature);
+
+    // Prevent memory leak!
+    mbedtls_x509_crt_free(&cert);
+
     return ret;
 }
 
@@ -258,7 +292,11 @@ int verify_ias_certificate_chain(attestation_verification_report_t* attn_report)
     ret = mbedtls_x509_crt_verify(&cert, &cacert, NULL, NULL, &flags,
                                   NULL, NULL);
     assert(ret == 0);
-    
+   
+    // Prevent memory leaks!
+    mbedtls_x509_crt_free(&cacert);
+    mbedtls_x509_crt_free(&cert);
+
     return ret;
 }
 
@@ -276,27 +314,40 @@ int verify_sgx_cert_extensions
     mbedtls_x509_crt crt;
     mbedtls_x509_crt_init(&crt);
     
-    int ret;
-    ret = mbedtls_x509_crt_parse(&crt, der_crt, der_crt_len);
+    if (mbedtls_x509_crt_parse(&crt, der_crt, der_crt_len) != 0) {
+            return 1;
+    }
     
-    extract_x509_extensions(crt.v3_ext.p,
+    if (extract_x509_extensions(crt.v3_ext.p,
                             crt.v3_ext.len,
-                            &attn_report);
-
-    ret = verify_ias_certificate_chain(&attn_report);
-    assert(ret == 0);
-
-    ret = verify_ias_report_signature(&attn_report);
-    assert(ret == 0);
+                                &attn_report) != 0) {
+        goto error;
+    }
 
+    if(verify_ias_certificate_chain(&attn_report) != 0) {
+        goto error;
+    }
+    
+    if(verify_ias_report_signature(&attn_report) != 0) {
+        goto error;
+    }
+    
     sgx_quote_t quote = {0, };
-    get_quote_from_report(attn_report.ias_report,
+    if (get_quote_from_report(attn_report.ias_report,
                           attn_report.ias_report_len,
-                          &quote);
-    ret = verify_report_data_against_server_cert(&crt, &quote);
-    assert(ret == 0);
+                              &quote) != 0) {
+        goto error;
+    }
+    
+    
+    if(verify_report_data_against_server_cert(&crt, &quote) != 0) {
+        goto error;
+    }
 
     mbedtls_x509_crt_free(&crt);
-
     return 0;
+        
+error:
+    mbedtls_x509_crt_free(&crt);
+    return 1;
 }
diff --git a/my_etc_files/group b/my_etc_files/group
new file mode 120000
index 0000000..3075d99
--- /dev/null
+++ b/my_etc_files/group
@@ -0,0 +1 @@
+/etc/group
\ No newline at end of file
diff --git a/my_etc_files/host.conf b/my_etc_files/host.conf
new file mode 100644
index 0000000..d1a59f7
--- /dev/null
+++ b/my_etc_files/host.conf
@@ -0,0 +1 @@
+multi on
diff --git a/my_etc_files/hosts b/my_etc_files/hosts
new file mode 100644
index 0000000..686619c
--- /dev/null
+++ b/my_etc_files/hosts
@@ -0,0 +1,30 @@
+127.0.0.1 localhost
+::1 localhost ip6-localhost ip6-loopback
+fe00::0	ip6-localnet
+ff00::0	ip6-mcastprefix
+ff02::1	ip6-allnodes
+ff02::2	ip6-allrouters
+
+# For new API
+40.87.90.88 api.trustedservices.intel.com
+
+# For old API
+18.213.212.17 test-as.sgx.trustedservices.intel.com
+34.233.76.225 test-as.sgx.trustedservices.intel.com
+35.170.91.60 test-as.sgx.trustedservices.intel.com
+
+#3.92.36.62 test-as.sgx.trustedservices.intel.com
+#34.229.8.27 test-as.sgx.trustedservices.intel.com
+#52.45.130.142 test-as.sgx.trustedservices.intel.com
+
+#34.197.155.37 test-as.sgx.trustedservices.intel.com
+#3.89.51.73 test-as.sgx.trustedservices.intel.com
+#3.213.108.86 test-as.sgx.trustedservices.intel.com
+
+#54.242.184.79 test-as.sgx.trustedservices.intel.com
+#54.205.7.250 test-as.sgx.trustedservices.intel.com
+#52.23.102.57 test-as.sgx.trustedservices.intel.com
+
+#18.210.146.127 test-as.sgx.trustedservices.intel.com
+#52.203.92.184 test-as.sgx.trustedservices.intel.com
+#35.169.102.107 test-as.sgx.trustedservices.intel.com
diff --git a/my_etc_files/localtime b/my_etc_files/localtime
new file mode 120000
index 0000000..92ba4ff
--- /dev/null
+++ b/my_etc_files/localtime
@@ -0,0 +1 @@
+/etc/localtime
\ No newline at end of file
diff --git a/my_etc_files/nsswitch.conf b/my_etc_files/nsswitch.conf
new file mode 100644
index 0000000..0be6b6e
--- /dev/null
+++ b/my_etc_files/nsswitch.conf
@@ -0,0 +1,21 @@
+# /etc/nsswitch.conf
+#
+# Example configuration of GNU Name Service Switch functionality.
+# If you have the `glibc-doc-reference' and `info' packages installed, try:
+# `info libc "Name Service Switch"' for information about this file.
+
+passwd:         compat
+group:          compat
+shadow:         compat
+gshadow:        files
+
+#hosts:          files dns
+hosts:          files #dns
+networks:       files
+
+protocols:      db files
+services:       db files
+ethers:         db files
+rpc:            db files
+
+netgroup:       nis
diff --git a/my_etc_files/passwd b/my_etc_files/passwd
new file mode 120000
index 0000000..3594e94
--- /dev/null
+++ b/my_etc_files/passwd
@@ -0,0 +1 @@
+/etc/passwd
\ No newline at end of file
diff --git a/my_etc_files/resolv.conf b/my_etc_files/resolv.conf
new file mode 100644
index 0000000..4d59090
--- /dev/null
+++ b/my_etc_files/resolv.conf
@@ -0,0 +1,4 @@
+search example.com
+domain example.com
+nameserver 8.8.8.8
+options edns0 ndots:0
diff --git a/my_etc_files/services b/my_etc_files/services
new file mode 100644
index 0000000..704cd12
--- /dev/null
+++ b/my_etc_files/services
@@ -0,0 +1,612 @@
+# Network services, Internet style
+#
+# Note that it is presently the policy of IANA to assign a single well-known
+# port number for both TCP and UDP; hence, officially ports have two entries
+# even if the protocol doesn't support UDP operations.
+#
+# Updated from http://www.iana.org/assignments/port-numbers and other
+# sources like http://www.freebsd.org/cgi/cvsweb.cgi/src/etc/services .
+# New ports will be added on request if they have been officially assigned
+# by IANA and used in the real-world or are needed by a debian package.
+# If you need a huge list of used numbers please install the nmap package.
+
+tcpmux		1/tcp				# TCP port service multiplexer
+echo		7/tcp
+echo		7/udp
+discard		9/tcp		sink null
+discard		9/udp		sink null
+systat		11/tcp		users
+daytime		13/tcp
+daytime		13/udp
+netstat		15/tcp
+qotd		17/tcp		quote
+msp		18/tcp				# message send protocol
+msp		18/udp
+chargen		19/tcp		ttytst source
+chargen		19/udp		ttytst source
+ftp-data	20/tcp
+ftp		21/tcp
+fsp		21/udp		fspd
+ssh		22/tcp				# SSH Remote Login Protocol
+ssh		22/udp
+telnet		23/tcp
+smtp		25/tcp		mail
+time		37/tcp		timserver
+time		37/udp		timserver
+rlp		39/udp		resource	# resource location
+nameserver	42/tcp		name		# IEN 116
+whois		43/tcp		nicname
+tacacs		49/tcp				# Login Host Protocol (TACACS)
+tacacs		49/udp
+re-mail-ck	50/tcp				# Remote Mail Checking Protocol
+re-mail-ck	50/udp
+domain		53/tcp				# Domain Name Server
+domain		53/udp
+mtp		57/tcp				# deprecated
+tacacs-ds	65/tcp				# TACACS-Database Service
+tacacs-ds	65/udp
+bootps		67/tcp				# BOOTP server
+bootps		67/udp
+bootpc		68/tcp				# BOOTP client
+bootpc		68/udp
+tftp		69/udp
+gopher		70/tcp				# Internet Gopher
+gopher		70/udp
+rje		77/tcp		netrjs
+finger		79/tcp
+http		80/tcp		www		# WorldWideWeb HTTP
+http		80/udp				# HyperText Transfer Protocol
+link		87/tcp		ttylink
+kerberos	88/tcp		kerberos5 krb5 kerberos-sec	# Kerberos v5
+kerberos	88/udp		kerberos5 krb5 kerberos-sec	# Kerberos v5
+supdup		95/tcp
+hostnames	101/tcp		hostname	# usually from sri-nic
+iso-tsap	102/tcp		tsap		# part of ISODE
+acr-nema	104/tcp		dicom		# Digital Imag. & Comm. 300
+acr-nema	104/udp		dicom
+csnet-ns	105/tcp		cso-ns		# also used by CSO name server
+csnet-ns	105/udp		cso-ns
+rtelnet		107/tcp				# Remote Telnet
+rtelnet		107/udp
+pop2		109/tcp		postoffice pop-2 # POP version 2
+pop2		109/udp		pop-2
+pop3		110/tcp		pop-3		# POP version 3
+pop3		110/udp		pop-3
+sunrpc		111/tcp		portmapper	# RPC 4.0 portmapper
+sunrpc		111/udp		portmapper
+auth		113/tcp		authentication tap ident
+sftp		115/tcp
+uucp-path	117/tcp
+nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
+ntp		123/tcp
+ntp		123/udp				# Network Time Protocol
+pwdgen		129/tcp				# PWDGEN service
+pwdgen		129/udp
+loc-srv		135/tcp		epmap		# Location Service
+loc-srv		135/udp		epmap
+netbios-ns	137/tcp				# NETBIOS Name Service
+netbios-ns	137/udp
+netbios-dgm	138/tcp				# NETBIOS Datagram Service
+netbios-dgm	138/udp
+netbios-ssn	139/tcp				# NETBIOS session service
+netbios-ssn	139/udp
+imap2		143/tcp		imap		# Interim Mail Access P 2 and 4
+imap2		143/udp		imap
+snmp		161/tcp				# Simple Net Mgmt Protocol
+snmp		161/udp
+snmp-trap	162/tcp		snmptrap	# Traps for SNMP
+snmp-trap	162/udp		snmptrap
+cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
+cmip-man	163/udp
+cmip-agent	164/tcp
+cmip-agent	164/udp
+mailq		174/tcp			# Mailer transport queue for Zmailer
+mailq		174/udp
+xdmcp		177/tcp				# X Display Mgr. Control Proto
+xdmcp		177/udp
+nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
+nextstep	178/udp		NeXTStep NextStep	#  server
+bgp		179/tcp				# Border Gateway Protocol
+bgp		179/udp
+prospero	191/tcp				# Cliff Neuman's Prospero
+prospero	191/udp
+irc		194/tcp				# Internet Relay Chat
+irc		194/udp
+smux		199/tcp				# SNMP Unix Multiplexer
+smux		199/udp
+at-rtmp		201/tcp				# AppleTalk routing
+at-rtmp		201/udp
+at-nbp		202/tcp				# AppleTalk name binding
+at-nbp		202/udp
+at-echo		204/tcp				# AppleTalk echo
+at-echo		204/udp
+at-zis		206/tcp				# AppleTalk zone information
+at-zis		206/udp
+qmtp		209/tcp				# Quick Mail Transfer Protocol
+qmtp		209/udp
+z3950		210/tcp		wais		# NISO Z39.50 database
+z3950		210/udp		wais
+ipx		213/tcp				# IPX
+ipx		213/udp
+imap3		220/tcp				# Interactive Mail Access
+imap3		220/udp				# Protocol v3
+pawserv		345/tcp				# Perf Analysis Workbench
+pawserv		345/udp
+zserv		346/tcp				# Zebra server
+zserv		346/udp
+fatserv		347/tcp				# Fatmen Server
+fatserv		347/udp
+rpc2portmap	369/tcp
+rpc2portmap	369/udp				# Coda portmapper
+codaauth2	370/tcp
+codaauth2	370/udp				# Coda authentication server
+clearcase	371/tcp		Clearcase
+clearcase	371/udp		Clearcase
+ulistserv	372/tcp				# UNIX Listserv
+ulistserv	372/udp
+ldap		389/tcp			# Lightweight Directory Access Protocol
+ldap		389/udp
+imsp		406/tcp			# Interactive Mail Support Protocol
+imsp		406/udp
+svrloc		427/tcp				# Server Location
+svrloc		427/udp
+https		443/tcp				# http protocol over TLS/SSL
+https		443/udp
+snpp		444/tcp				# Simple Network Paging Protocol
+snpp		444/udp
+microsoft-ds	445/tcp				# Microsoft Naked CIFS
+microsoft-ds	445/udp
+kpasswd		464/tcp
+kpasswd		464/udp
+urd		465/tcp		ssmtp smtps  # URL Rendesvous Directory for SSM
+saft		487/tcp			# Simple Asynchronous File Transfer
+saft		487/udp
+isakmp		500/tcp			# IPsec - Internet Security Association
+isakmp		500/udp			#  and Key Management Protocol
+rtsp		554/tcp			# Real Time Stream Control Protocol
+rtsp		554/udp
+nqs		607/tcp				# Network Queuing system
+nqs		607/udp
+npmp-local	610/tcp		dqs313_qmaster		# npmp-local / DQS
+npmp-local	610/udp		dqs313_qmaster
+npmp-gui	611/tcp		dqs313_execd		# npmp-gui / DQS
+npmp-gui	611/udp		dqs313_execd
+hmmp-ind	612/tcp		dqs313_intercell	# HMMP Indication / DQS
+hmmp-ind	612/udp		dqs313_intercell
+asf-rmcp	623/udp		# ASF Remote Management and Control Protocol
+qmqp		628/tcp
+qmqp		628/udp
+ipp		631/tcp				# Internet Printing Protocol
+ipp		631/udp
+#
+# UNIX specific services
+#
+exec		512/tcp
+biff		512/udp		comsat
+login		513/tcp
+who		513/udp		whod
+shell		514/tcp		cmd		# no passwords used
+syslog		514/udp
+printer		515/tcp		spooler		# line printer spooler
+talk		517/udp
+ntalk		518/udp
+route		520/udp		router routed	# RIP
+timed		525/udp		timeserver
+tempo		526/tcp		newdate
+courier		530/tcp		rpc
+conference	531/tcp		chat
+netnews		532/tcp		readnews
+netwall		533/udp				# for emergency broadcasts
+gdomap		538/tcp				# GNUstep distributed objects
+gdomap		538/udp
+uucp		540/tcp		uucpd		# uucp daemon
+klogin		543/tcp				# Kerberized `rlogin' (v5)
+kshell		544/tcp		krcmd		# Kerberized `rsh' (v5)
+dhcpv6-client	546/tcp
+dhcpv6-client	546/udp
+dhcpv6-server	547/tcp
+dhcpv6-server	547/udp
+afpovertcp	548/tcp				# AFP over TCP
+afpovertcp	548/udp
+idfp		549/tcp
+idfp		549/udp
+remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
+nntps		563/tcp		snntp		# NNTP over SSL
+nntps		563/udp		snntp
+submission	587/tcp				# Submission [RFC4409]
+submission	587/udp
+ldaps		636/tcp				# LDAP over SSL
+ldaps		636/udp
+tinc		655/tcp				# tinc control port
+tinc		655/udp
+silc		706/tcp
+silc		706/udp
+kerberos-adm	749/tcp				# Kerberos `kadmin' (v5)
+#
+webster		765/tcp				# Network dictionary
+webster		765/udp
+rsync		873/tcp
+rsync		873/udp
+ftps-data	989/tcp				# FTP over SSL (data)
+ftps		990/tcp
+telnets		992/tcp				# Telnet over SSL
+telnets		992/udp
+imaps		993/tcp				# IMAP over SSL
+imaps		993/udp
+ircs		994/tcp				# IRC over SSL
+ircs		994/udp
+pop3s		995/tcp				# POP-3 over SSL
+pop3s		995/udp
+#
+# From ``Assigned Numbers'':
+#
+#> The Registered Ports are not controlled by the IANA and on most systems
+#> can be used by ordinary user processes or programs executed by ordinary
+#> users.
+#
+#> Ports are used in the TCP [45,106] to name the ends of logical
+#> connections which carry long term conversations.  For the purpose of
+#> providing services to unknown callers, a service contact port is
+#> defined.  This list specifies the port used by the server process as its
+#> contact port.  While the IANA can not control uses of these ports it
+#> does register or list uses of these ports as a convienence to the
+#> community.
+#
+socks		1080/tcp			# socks proxy server
+socks		1080/udp
+proofd		1093/tcp
+proofd		1093/udp
+rootd		1094/tcp
+rootd		1094/udp
+openvpn		1194/tcp
+openvpn		1194/udp
+rmiregistry	1099/tcp			# Java RMI Registry
+rmiregistry	1099/udp
+kazaa		1214/tcp
+kazaa		1214/udp
+nessus		1241/tcp			# Nessus vulnerability
+nessus		1241/udp			#  assessment scanner
+lotusnote	1352/tcp	lotusnotes	# Lotus Note
+lotusnote	1352/udp	lotusnotes
+ms-sql-s	1433/tcp			# Microsoft SQL Server
+ms-sql-s	1433/udp
+ms-sql-m	1434/tcp			# Microsoft SQL Monitor
+ms-sql-m	1434/udp
+ingreslock	1524/tcp
+ingreslock	1524/udp
+prospero-np	1525/tcp			# Prospero non-privileged
+prospero-np	1525/udp
+datametrics	1645/tcp	old-radius
+datametrics	1645/udp	old-radius
+sa-msg-port	1646/tcp	old-radacct
+sa-msg-port	1646/udp	old-radacct
+kermit		1649/tcp
+kermit		1649/udp
+groupwise	1677/tcp
+groupwise	1677/udp
+l2f		1701/tcp	l2tp
+l2f		1701/udp	l2tp
+radius		1812/tcp
+radius		1812/udp
+radius-acct	1813/tcp	radacct		# Radius Accounting
+radius-acct	1813/udp	radacct
+msnp		1863/tcp			# MSN Messenger
+msnp		1863/udp
+unix-status	1957/tcp			# remstats unix-status server
+log-server	1958/tcp			# remstats log server
+remoteping	1959/tcp			# remstats remoteping server
+cisco-sccp	2000/tcp			# Cisco SCCP
+cisco-sccp	2000/udp
+search		2010/tcp	ndtp
+pipe-server	2010/tcp	pipe_server
+nfs		2049/tcp			# Network File System
+nfs		2049/udp			# Network File System
+gnunet		2086/tcp
+gnunet		2086/udp
+rtcm-sc104	2101/tcp			# RTCM SC-104 IANA 1/29/99
+rtcm-sc104	2101/udp
+gsigatekeeper	2119/tcp
+gsigatekeeper	2119/udp
+gris		2135/tcp		# Grid Resource Information Server
+gris		2135/udp
+cvspserver	2401/tcp			# CVS client/server operations
+cvspserver	2401/udp
+venus		2430/tcp			# codacon port
+venus		2430/udp			# Venus callback/wbc interface
+venus-se	2431/tcp			# tcp side effects
+venus-se	2431/udp			# udp sftp side effect
+codasrv		2432/tcp			# not used
+codasrv		2432/udp			# server port
+codasrv-se	2433/tcp			# tcp side effects
+codasrv-se	2433/udp			# udp sftp side effect
+mon		2583/tcp			# MON traps
+mon		2583/udp
+dict		2628/tcp			# Dictionary server
+dict		2628/udp
+f5-globalsite	2792/tcp
+f5-globalsite	2792/udp
+gsiftp		2811/tcp
+gsiftp		2811/udp
+gpsd		2947/tcp
+gpsd		2947/udp
+gds-db		3050/tcp	gds_db		# InterBase server
+gds-db		3050/udp	gds_db
+icpv2		3130/tcp	icp		# Internet Cache Protocol
+icpv2		3130/udp	icp
+iscsi-target	3260/tcp
+mysql		3306/tcp
+mysql		3306/udp
+nut		3493/tcp			# Network UPS Tools
+nut		3493/udp
+distcc		3632/tcp			# distributed compiler
+distcc		3632/udp
+daap		3689/tcp			# Digital Audio Access Protocol
+daap		3689/udp
+svn		3690/tcp	subversion	# Subversion protocol
+svn		3690/udp	subversion
+suucp		4031/tcp			# UUCP over SSL
+suucp		4031/udp
+sysrqd		4094/tcp			# sysrq daemon
+sysrqd		4094/udp
+sieve		4190/tcp			# ManageSieve Protocol
+epmd		4369/tcp			# Erlang Port Mapper Daemon
+epmd		4369/udp
+remctl		4373/tcp		# Remote Authenticated Command Service
+remctl		4373/udp
+f5-iquery	4353/tcp			# F5 iQuery
+f5-iquery	4353/udp
+ipsec-nat-t	4500/udp			# IPsec NAT-Traversal [RFC3947]
+iax		4569/tcp			# Inter-Asterisk eXchange
+iax		4569/udp
+mtn		4691/tcp			# monotone Netsync Protocol
+mtn		4691/udp
+radmin-port	4899/tcp			# RAdmin Port
+radmin-port	4899/udp
+rfe		5002/udp			# Radio Free Ethernet
+rfe		5002/tcp
+mmcc		5050/tcp	# multimedia conference control tool (Yahoo IM)
+mmcc		5050/udp
+sip		5060/tcp			# Session Initiation Protocol
+sip		5060/udp
+sip-tls		5061/tcp
+sip-tls		5061/udp
+aol		5190/tcp			# AIM
+aol		5190/udp
+xmpp-client	5222/tcp	jabber-client	# Jabber Client Connection
+xmpp-client	5222/udp	jabber-client
+xmpp-server	5269/tcp	jabber-server	# Jabber Server Connection
+xmpp-server	5269/udp	jabber-server
+cfengine	5308/tcp
+cfengine	5308/udp
+mdns		5353/tcp			# Multicast DNS
+mdns		5353/udp
+postgresql	5432/tcp	postgres	# PostgreSQL Database
+postgresql	5432/udp	postgres
+freeciv		5556/tcp	rptp		# Freeciv gameplay
+freeciv		5556/udp
+amqps		5671/tcp			# AMQP protocol over TLS/SSL
+amqp		5672/tcp
+amqp		5672/udp
+amqp		5672/sctp
+ggz		5688/tcp			# GGZ Gaming Zone
+ggz		5688/udp
+x11		6000/tcp	x11-0		# X Window System
+x11		6000/udp	x11-0
+x11-1		6001/tcp
+x11-1		6001/udp
+x11-2		6002/tcp
+x11-2		6002/udp
+x11-3		6003/tcp
+x11-3		6003/udp
+x11-4		6004/tcp
+x11-4		6004/udp
+x11-5		6005/tcp
+x11-5		6005/udp
+x11-6		6006/tcp
+x11-6		6006/udp
+x11-7		6007/tcp
+x11-7		6007/udp
+gnutella-svc	6346/tcp			# gnutella
+gnutella-svc	6346/udp
+gnutella-rtr	6347/tcp			# gnutella
+gnutella-rtr	6347/udp
+sge-qmaster	6444/tcp	sge_qmaster	# Grid Engine Qmaster Service
+sge-qmaster	6444/udp	sge_qmaster
+sge-execd	6445/tcp	sge_execd	# Grid Engine Execution Service
+sge-execd	6445/udp	sge_execd
+mysql-proxy	6446/tcp			# MySQL Proxy
+mysql-proxy	6446/udp
+afs3-fileserver 7000/tcp	bbs		# file server itself
+afs3-fileserver 7000/udp	bbs
+afs3-callback	7001/tcp			# callbacks to cache managers
+afs3-callback	7001/udp
+afs3-prserver	7002/tcp			# users & groups database
+afs3-prserver	7002/udp
+afs3-vlserver	7003/tcp			# volume location database
+afs3-vlserver	7003/udp
+afs3-kaserver	7004/tcp			# AFS/Kerberos authentication
+afs3-kaserver	7004/udp
+afs3-volser	7005/tcp			# volume managment server
+afs3-volser	7005/udp
+afs3-errors	7006/tcp			# error interpretation service
+afs3-errors	7006/udp
+afs3-bos	7007/tcp			# basic overseer process
+afs3-bos	7007/udp
+afs3-update	7008/tcp			# server-to-server updater
+afs3-update	7008/udp
+afs3-rmtsys	7009/tcp			# remote cache manager service
+afs3-rmtsys	7009/udp
+font-service	7100/tcp	xfs		# X Font Service
+font-service	7100/udp	xfs
+http-alt	8080/tcp	webcache	# WWW caching service
+http-alt	8080/udp
+bacula-dir	9101/tcp			# Bacula Director
+bacula-dir	9101/udp
+bacula-fd	9102/tcp			# Bacula File Daemon
+bacula-fd	9102/udp
+bacula-sd	9103/tcp			# Bacula Storage Daemon
+bacula-sd	9103/udp
+xmms2		9667/tcp	# Cross-platform Music Multiplexing System
+xmms2		9667/udp
+nbd		10809/tcp			# Linux Network Block Device
+zabbix-agent	10050/tcp			# Zabbix Agent
+zabbix-agent	10050/udp
+zabbix-trapper	10051/tcp			# Zabbix Trapper
+zabbix-trapper	10051/udp
+amanda		10080/tcp			# amanda backup services
+amanda		10080/udp
+dicom		11112/tcp
+hkp		11371/tcp			# OpenPGP HTTP Keyserver
+hkp		11371/udp
+bprd		13720/tcp			# VERITAS NetBackup
+bprd		13720/udp
+bpdbm		13721/tcp			# VERITAS NetBackup
+bpdbm		13721/udp
+bpjava-msvc	13722/tcp			# BP Java MSVC Protocol
+bpjava-msvc	13722/udp
+vnetd		13724/tcp			# Veritas Network Utility
+vnetd		13724/udp
+bpcd		13782/tcp			# VERITAS NetBackup
+bpcd		13782/udp
+vopied		13783/tcp			# VERITAS NetBackup
+vopied		13783/udp
+db-lsp		17500/tcp			# Dropbox LanSync Protocol
+dcap		22125/tcp			# dCache Access Protocol
+gsidcap		22128/tcp			# GSI dCache Access Protocol
+wnn6		22273/tcp			# wnn6
+wnn6		22273/udp
+
+#
+# Datagram Delivery Protocol services
+#
+rtmp		1/ddp			# Routing Table Maintenance Protocol
+nbp		2/ddp			# Name Binding Protocol
+echo		4/ddp			# AppleTalk Echo Protocol
+zip		6/ddp			# Zone Information Protocol
+
+#=========================================================================
+# The remaining port numbers are not as allocated by IANA.
+#=========================================================================
+
+# Kerberos (Project Athena/MIT) services
+# Note that these are for Kerberos v4, and are unofficial.  Sites running
+# v4 should uncomment these and comment out the v5 entries above.
+#
+kerberos4	750/udp		kerberos-iv kdc	# Kerberos (server)
+kerberos4	750/tcp		kerberos-iv kdc
+kerberos-master	751/udp		kerberos_master	# Kerberos authentication
+kerberos-master	751/tcp
+passwd-server	752/udp		passwd_server	# Kerberos passwd server
+krb-prop	754/tcp		krb_prop krb5_prop hprop # Kerberos slave propagation
+krbupdate	760/tcp		kreg		# Kerberos registration
+swat		901/tcp				# swat
+kpop		1109/tcp			# Pop with Kerberos
+knetd		2053/tcp			# Kerberos de-multiplexor
+zephyr-srv	2102/udp			# Zephyr server
+zephyr-clt	2103/udp			# Zephyr serv-hm connection
+zephyr-hm	2104/udp			# Zephyr hostmanager
+eklogin		2105/tcp			# Kerberos encrypted rlogin
+# Hmmm. Are we using Kv4 or Kv5 now? Worrying.
+# The following is probably Kerberos v5  --- ajt@debian.org (11/02/2000)
+kx		2111/tcp			# X over Kerberos
+iprop		2121/tcp			# incremental propagation
+#
+# Unofficial but necessary (for NetBSD) services
+#
+supfilesrv	871/tcp				# SUP server
+supfiledbg	1127/tcp			# SUP debugging
+
+#
+# Services added for the Debian GNU/Linux distribution
+#
+linuxconf	98/tcp				# LinuxConf
+poppassd	106/tcp				# Eudora
+poppassd	106/udp
+moira-db	775/tcp		moira_db	# Moira database
+moira-update	777/tcp		moira_update	# Moira update protocol
+moira-ureg	779/udp		moira_ureg	# Moira user registration
+spamd		783/tcp				# spamassassin daemon
+omirr		808/tcp		omirrd		# online mirror
+omirr		808/udp		omirrd
+customs		1001/tcp			# pmake customs server
+customs		1001/udp
+skkserv		1178/tcp			# skk jisho server port
+predict		1210/udp			# predict -- satellite tracking
+rmtcfg		1236/tcp			# Gracilis Packeten remote config server
+wipld		1300/tcp			# Wipl network monitor
+xtel		1313/tcp			# french minitel
+xtelw		1314/tcp			# french minitel
+support		1529/tcp			# GNATS
+cfinger		2003/tcp			# GNU Finger
+frox		2121/tcp			# frox: caching ftp proxy
+ninstall	2150/tcp			# ninstall service
+ninstall	2150/udp
+zebrasrv	2600/tcp			# zebra service
+zebra		2601/tcp			# zebra vty
+ripd		2602/tcp			# ripd vty (zebra)
+ripngd		2603/tcp			# ripngd vty (zebra)
+ospfd		2604/tcp			# ospfd vty (zebra)
+bgpd		2605/tcp			# bgpd vty (zebra)
+ospf6d		2606/tcp			# ospf6d vty (zebra)
+ospfapi		2607/tcp			# OSPF-API
+isisd		2608/tcp			# ISISd vty (zebra)
+afbackup	2988/tcp			# Afbackup system
+afbackup	2988/udp
+afmbackup	2989/tcp			# Afmbackup system
+afmbackup	2989/udp
+xtell		4224/tcp			# xtell server
+fax		4557/tcp			# FAX transmission service (old)
+hylafax		4559/tcp			# HylaFAX client-server protocol (new)
+distmp3		4600/tcp			# distmp3host daemon
+munin		4949/tcp	lrrd		# Munin
+enbd-cstatd	5051/tcp			# ENBD client statd
+enbd-sstatd	5052/tcp			# ENBD server statd
+pcrd		5151/tcp			# PCR-1000 Daemon
+noclog		5354/tcp			# noclogd with TCP (nocol)
+noclog		5354/udp			# noclogd with UDP (nocol)
+hostmon		5355/tcp			# hostmon uses TCP (nocol)
+hostmon		5355/udp			# hostmon uses UDP (nocol)
+rplay		5555/udp			# RPlay audio service
+nrpe		5666/tcp			# Nagios Remote Plugin Executor
+nsca		5667/tcp			# Nagios Agent - NSCA
+mrtd		5674/tcp			# MRT Routing Daemon
+bgpsim		5675/tcp			# MRT Routing Simulator
+canna		5680/tcp			# cannaserver
+syslog-tls	6514/tcp			# Syslog over TLS [RFC5425]
+sane-port	6566/tcp	sane saned	# SANE network scanner daemon
+ircd		6667/tcp			# Internet Relay Chat
+zope-ftp	8021/tcp			# zope management by ftp
+tproxy		8081/tcp			# Transparent Proxy
+omniorb		8088/tcp			# OmniORB
+omniorb		8088/udp
+clc-build-daemon 8990/tcp			# Common lisp build daemon
+xinetd		9098/tcp
+mandelspawn	9359/udp	mandelbrot	# network mandelbrot
+git		9418/tcp			# Git Version Control System
+zope		9673/tcp			# zope server
+webmin		10000/tcp
+kamanda		10081/tcp			# amanda backup services (Kerberos)
+kamanda		10081/udp
+amandaidx	10082/tcp			# amanda backup services
+amidxtape	10083/tcp			# amanda backup services
+smsqp		11201/tcp			# Alamin SMS gateway
+smsqp		11201/udp
+xpilot		15345/tcp			# XPilot Contact Port
+xpilot		15345/udp
+sgi-cmsd	17001/udp		# Cluster membership services daemon
+sgi-crsd	17002/udp
+sgi-gcd		17003/udp			# SGI Group membership daemon
+sgi-cad		17004/tcp			# Cluster Admin daemon
+isdnlog		20011/tcp			# isdn logging system
+isdnlog		20011/udp
+vboxd		20012/tcp			# voice box system
+vboxd		20012/udp
+binkp		24554/tcp			# binkp fidonet protocol
+asp		27374/tcp			# Address Search Protocol
+asp		27374/udp
+csync2		30865/tcp			# cluster synchronization tool
+dircproxy	57000/tcp			# Detachable IRC Proxy
+tfido		60177/tcp			# fidonet EMSI over telnet
+fido		60179/tcp			# fidonet EMSI over TCP
+
+# Local services
diff --git a/my_etc_files/ssl/openssl.cnf b/my_etc_files/ssl/openssl.cnf
new file mode 120000
index 0000000..b307285
--- /dev/null
+++ b/my_etc_files/ssl/openssl.cnf
@@ -0,0 +1 @@
+/etc/ssl/openssl.cnf
\ No newline at end of file
diff --git a/new-demo-client.manifest b/new-demo-client.manifest
new file mode 100644
index 0000000..1b608db
--- /dev/null
+++ b/new-demo-client.manifest
@@ -0,0 +1,94 @@
+loader.preload = file:deps/graphene/Runtime/libsysdb.so
+loader.env.LD_LIBRARY_PATH = /lib
+#loader.env.LD_DEBUG = files
+#loader.debug_type = inline
+loader.env.MALLOC_CHECK_ = 1
+loader.debug_type = none
+loader.syscall_symbol = syscalldb
+
+loader.env.LD_PRELOAD = deps/graphene/Runtime/libseng_onload.so
+#loader.env.LD_PRELOAD = deps/graphene/Runtime/liblwip_no_seng_onload.so
+fs.mount.tundev.type = chroot
+fs.mount.tundev.path = /dev/net/tun
+fs.mount.tundev.uri = file:/dev/net/tun
+sgx.allowed_files.tun = file:/dev/net/tun
+
+fs.mount.lib.type = chroot
+fs.mount.lib.path = /lib
+fs.mount.lib.uri = file:deps/graphene/Runtime
+
+fs.mount.bin.type = chroot
+fs.mount.bin.path = /bin
+fs.mount.bin.uri = file:/bin
+
+sgx.enclave_size = 1024M
+sys.brk.size = 64M
+sys.stack.size = 8M
+
+# 4 seems to cause "Cannot attach to any TCS!"
+sgx.thread_num = 6
+
+# allow to bind on port 8000
+#net.allow_bind.1 = 127.0.0.1:8000
+# allow to connect to port 8000
+net.allow_peer.1 = 111.222.111.222:12345
+net.allow.peer.2 = 34.234.230.147:443
+
+#net.allow_bind.https = 127.0.0.1:4433
+#net.allow_peer.https = 127.0.0.1:4433
+
+# sgx-related
+sgx.trusted_files.libonloadseng = file:deps/graphene/Runtime/libseng_onload.so
+sgx.trusted_files.libonloadlwiponly = file:deps/graphene/Runtime/liblwip_no_seng_onload.so
+sgx.trusted_files.libdtlsif = file:deps/graphene/Runtime/libseng_tunnel_netif.so
+sgx.trusted_files.liblwiptunif = file:deps/graphene/Runtime/libadapted_lwip_tun_netif.so
+sgx.trusted_files.liblwip = file:deps/graphene/Runtime/liblwip.so
+
+sgx.trusted_files.ld = file:deps/graphene/Runtime/ld-linux-x86-64.so.2
+sgx.trusted_files.libdl = file:deps/graphene/Runtime/libdl.so.2
+sgx.trusted_files.libpthread = file:deps/graphene/Runtime/libpthread.so.0
+sgx.trusted_files.libc = file:deps/graphene/Runtime/libc.so.6
+sgx.trusted_files.libm = file:deps/graphene/Runtime/libm.so.6
+
+sgx.trusted_files.libprotobufc = file:deps/graphene/Runtime/libprotobuf-c.so.1
+sgx.trusted_files.libresolv = file:deps/graphene/Runtime/libresolv.so.2
+sgx.trusted_files.libnssdnsso2 = file:deps/graphene/Runtime/libnss_dns.so.2
+# [15.02.19]: allow lookup in /etc/hosts
+sgx.trusted_files.libnssfilesso2 = file:deps/graphene/Runtime/libnss_files.so.2
+
+sgx.trusted_files.libsgx_uae_service = file:deps/graphene/Runtime/libsgx_uae_service.so
+
+sgx.trusted_files.libcrypto = file:deps/graphene/Runtime/libcrypto.so.1.0.0
+sgx.trusted_files.libz = file:deps/graphene/Runtime/libz.so.1
+sgx.trusted_files.libssl = file:deps/graphene/Runtime/libssl.so.1.0.0
+
+# might in future want to use local version instead for compilation and then
+# create the symlink based on the local library version not the system-wide one
+#sgx.trusted_files.libcurl = file:/deps/local/lib/libcurl.4.so
+
+# via ./copy_libs_helper.bash
+# BUG Graphene cannot handle '-' character in trusted_files name (also of coure no '.')
+
+#new
+sgx.trusted_files.libcxx = file:deps/graphene/Runtime/libstdc++.so.6
+sgx.trusted_files.libgcc = file:deps/graphene/Runtime/libgcc_s.so.1
+
+sgx.trusted_files.libprotobufcpp = file:deps/graphene/Runtime/libprotobuf.so.9
+
+fs.mount.etc.type = chroot
+fs.mount.etc.path = /etc
+#fs.mount.etc.uri = file:/etc
+fs.mount.etc.uri = file:/home/encl-dev/sgx-ra-tls/my_etc_files
+
+sgx.trusted_files.cacertificates = file:/etc/ssl/certs/ca-certificates.crt
+
+sgx.trusted_files.client_ias_key = file:ias-client-key.pem
+sgx.trusted_files.client_ias_cert = file:ias-client-cert.pem
+
+sgx.trusted_files.myresolv = file:/home/encl-dev/sgx-ra-tls/my_etc_files/resolv.conf
+sgx.trusted_files.myhosts = file:/home/encl-dev/sgx-ra-tls/my_etc_files/hosts
+sgx.trusted_files.myhost = file:/home/encl-dev/sgx-ra-tls/my_etc_files/host.conf
+sgx.trusted_files.mynssw = file:/home/encl-dev/sgx-ra-tls/my_etc_files/nsswitch.conf
+
+# not required?
+sgx.trusted_files.services = file:/home/encl-dev/sgx-ra-tls/my_etc_files/services
diff --git a/new_try.bash b/new_try.bash
new file mode 100644
index 0000000..1e7595d
--- /dev/null
+++ b/new_try.bash
@@ -0,0 +1,23 @@
+#!/bin/bash
+cd ~/sgx-ra-tls/
+SGX_MODE=HW make mbedtls/libnonsdk-ra-attester.a || exit 1
+
+cd ~/client_enclave/lwip_based_client_lib/dock_build/
+SGX_MODE=HW make -j4 || exit 1
+cp ./my_demo ~/sgx-ra-tls/new_demo_client
+
+cd ~/sgx-ra-tls/
+deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output new_demo_client.manifest.sgx -exec new_demo_client -manifest new-demo-client.manifest || exit 1
+
+deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output new_demo_client.token -sig new_demo_client.sig || exit 1
+
+echo "*******************************************************************************************"
+echo "NOW GOING TO START THE ACTUAL PROGRAM"
+echo "*******************************************************************************************"
+
+ulimit -n 512
+
+#su -c "SGX=1 ./deps/graphene/Runtime/pal_loader ./ssl_client" root
+export SGX=1
+sudo -E ./deps/graphene/Runtime/pal_loader ./new_demo_client
+#./deps/graphene/Runtime/pal_loader ./new_demo_client
diff --git a/nonsdk-ra-attester.c b/nonsdk-ra-attester.c
index 6ec4eab..013a430 100644
--- a/nonsdk-ra-attester.c
+++ b/nonsdk-ra-attester.c
@@ -29,6 +29,12 @@
 #include <epid/common/types.h>
 #include <internal/se_quote_internal.h>
 
+#include <sys/time.h>
+
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
+//#define DEBUG
+
 /* Each protobuf is preceeded by its length stored in a uint32_t. */
 static uint32_t hdr_len = sizeof(uint32_t);
 
@@ -104,6 +110,10 @@ void init_quote_response
     memcpy(target_info, qr->targetinfo.data, sizeof(*target_info));
     memcpy(group_id, qr->gid.data, sizeof(*group_id));
 
+#ifdef DEBUG
+    printf("group_id: %x\n", *((unsigned int *)group_id));
+#endif
+
     free(reply); reply = NULL;
 }
 
@@ -113,6 +123,7 @@ int sgx_report(void*, void*, void*);
 static void hex_print(uint8_t* str, size_t len) {
     for (uint32_t i = 0; i < len; ++i) printf("%02x", str[i]);
     printf("\n");
+    fflush(stdout);
 }
 #endif
 
@@ -160,13 +171,19 @@ void create_report(
     memcpy_s(tmp_report_data, sizeof(*tmp_report_data), report_data, sizeof(*report_data));
 
     sgx_report(tmp_target_info, tmp_report_data, tmp_report);
-    /* for (int i = 0; i < sizeof(*report); ++i) printf("%02x", ((uint8_t*) tmp_report)[i]); */
+    //for (int i = 0; i < sizeof(*report); ++i) printf("%02x", ((uint8_t*) tmp_report)[i]); 
 
     memcpy_s(report, sizeof(*report), tmp_report, sizeof(*tmp_report));
 
-    /* hex_print((uint8_t*) report, sizeof(*report)); */
 #ifdef DEBUG
+    printf("report hex:\n");
+    hex_print((uint8_t*) report, sizeof(*report));
+    printf("\n");
+#endif
+#ifdef DEBUG
+    printf("MR ENCLAVE:\n");
     hex_print((uint8_t*) &report->body.mr_enclave, sizeof(sgx_measurement_t));
+    printf("MR SIGNER:\n");
     hex_print((uint8_t*) &report->body.mr_signer, sizeof(sgx_measurement_t));
 #endif
     
@@ -188,11 +205,15 @@ void get_quote_request(
 
     req.report.data = (uint8_t*) report;
     req.report.len = sizeof(*report);
-    /* printf("len report= %lu\n", sizeof(*report)); */
+#ifdef DEBUG
+    printf("len report= %lu\n", sizeof(*report));
+#endif
     req.quote_type = quote_type;
     req.spid.data = (uint8_t*) spid;
     req.spid.len = sizeof(*spid);
-    /* printf("len spid= %lu\n", sizeof(*spid)); */
+#ifdef DEBUG
+    printf("len spid= %lu\n", sizeof(*spid));
+#endif
     req.has_qe_report = 1;
     req.qe_report = 0;
     req.has_timeout = 1;
@@ -259,6 +280,10 @@ int open_socket(void) {
     saddr.sin_port = htons(1234);
     
     int rc = connect(fd, (const struct sockaddr*) &saddr, sizeof(saddr));
+#ifdef DEBUG
+    perror(NULL);
+#endif
+
     assert(rc != -1);
     
     return fd;
@@ -313,6 +338,16 @@ void do_remote_attestation
 )
 {
     uint32_t quote_size;
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_quote = 1;
+        struct timeval listen_tv_start_quote, listen_tv_end_quote;
+        if( gettimeofday(&listen_tv_start_quote, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_quote = 0;
+        }
+#endif
     sgx_quote_t* quote = alloc_quote(&quote_size);
     assert(quote != NULL);
 
@@ -321,10 +356,47 @@ void do_remote_attestation
               report_data,
               quote,
               quote_size);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_quote == 1 ) {
+            if ( gettimeofday(&listen_tv_end_quote, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_quote.tv_sec - listen_tv_start_quote.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_quote.tv_usec - listen_tv_start_quote.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "get_quote\n");
+                //fflush(stdout);
+            }
+        }
+#endif
 
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     obtain_attestation_verification_report(quote,
                                            quote_size,
                                            opts,
                                            attn_report);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "IAS\n");
+                //fflush(stdout);
+            }
+        }
+#endif
     free_quote(quote); quote = NULL;
 }
diff --git a/old_graphene.txt b/old_graphene.txt
new file mode 100644
index 0000000..0f4d83d
--- /dev/null
+++ b/old_graphene.txt
@@ -0,0 +1 @@
+aa449b2caf0dda850611aa7b2cf6c475ba60aa04
diff --git a/openssl-ra-attester.c b/openssl-ra-attester.c
new file mode 100644
index 0000000..a141b27
--- /dev/null
+++ b/openssl-ra-attester.c
@@ -0,0 +1,227 @@
+/* Code to create an extended X.509 certificate with OpenSSL. */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <sgx_uae_service.h>
+
+#include <openssl/rsa.h>
+#include <openssl/x509.h>
+
+#include "ra.h"
+#include "ra-attester.h"
+#include "ra-challenger_private.h"
+#include "ra_private.h"
+
+static const uint32_t SHA256_DIGEST_SIZE = 256 / 8;
+
+#include <sys/time.h>
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
+
+/**
+ * Caller must allocate memory for certificate.
+ * 
+ * @param der_crt_len On entry contains the size of der_crt buffer. On return holds actual size of certificate in bytes.
+ */
+static
+void generate_x509
+(
+    EVP_PKEY* key,   /* in */
+    uint8_t* der_crt, /* out */
+    int* der_crt_len, /* in/out */
+    attestation_verification_report_t* attn_report
+)
+{
+    X509* crt;
+    crt = X509_new();
+    
+    X509_set_version(crt, 2);
+    X509_gmtime_adj(X509_get_notBefore(crt), 0);
+    X509_gmtime_adj(X509_get_notAfter(crt), 31536000L);
+
+    X509_set_pubkey(crt, key);
+
+    X509_NAME* name;
+    name = X509_get_subject_name(crt);
+    
+    X509_NAME_add_entry_by_txt(name, "C",  MBSTRING_ASC,
+                               (unsigned char *)"US", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "ST",  MBSTRING_ASC,
+                               (unsigned char *)"OR", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "L",  MBSTRING_ASC,
+                               (unsigned char *)"Hillsboro", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "O",  MBSTRING_ASC,
+                               (unsigned char *)"Intel Inc.", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "OU",  MBSTRING_ASC,
+                               (unsigned char *)"Intel Labs", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
+                               (unsigned char *)"SGX rocks!", -1, -1, 0);
+
+    X509_set_issuer_name(crt, name);
+
+    ASN1_OBJECT obj = { .data = ias_response_body_oid + 2,
+                        .length = ias_oid_len - 2 };
+    ASN1_OCTET_STRING val = { .data = attn_report->ias_report,
+                              .length = attn_report->ias_report_len};
+    X509_EXTENSION ex = { &obj, 0, &val };
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_root_cert_oid + 2;
+    val.data   = attn_report->ias_sign_ca_cert;
+    val.length = attn_report->ias_sign_ca_cert_len;
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_leaf_cert_oid + 2;
+    val.data   = attn_report->ias_sign_cert;
+    val.length = attn_report->ias_sign_cert_len;
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_report_signature_oid + 2;
+    val.data   = attn_report->ias_report_signature;
+    val.length = attn_report->ias_report_signature_len;
+    X509_add_ext(crt, &ex, -1);
+
+    X509_sign(crt, key, EVP_sha256());
+
+    /* Encode X509 as DER. */
+    int len = i2d_X509(crt, NULL);
+    assert(len <= *der_crt_len);
+    i2d_X509(crt, &der_crt);
+    *der_crt_len = len;
+
+    X509_free(crt);
+    crt = NULL;
+}
+
+void sha256_rsa_pubkey
+(
+    unsigned char hash[SHA256_DIGEST_SIZE],
+    RSA* key
+)
+{
+    int len = i2d_RSAPublicKey(key, NULL);
+    assert(len > 0);
+    /* magic size of DER-encoded 2048 bit RSA public key. */
+    assert(len == 270);
+    
+    unsigned char buf[len];
+    unsigned char* p = buf;
+    len = i2d_RSAPublicKey(key, &p);
+
+    unsigned char md_value[EVP_MAX_MD_SIZE];
+    uint32_t md_len;
+
+    EVP_MD_CTX* mdctx = EVP_MD_CTX_create();
+    const EVP_MD* md = EVP_sha256();
+    EVP_DigestInit_ex(mdctx, md, NULL);
+    EVP_DigestUpdate(mdctx, buf, len);
+    EVP_DigestFinal_ex(mdctx, md_value, &md_len);
+    assert(md_len == SHA256_DIGEST_SIZE);
+    EVP_MD_CTX_destroy(mdctx);
+    memcpy(hash, md_value, SHA256_DIGEST_SIZE);
+}
+
+static void
+openssl_create_key_and_x509
+(
+    uint8_t* der_key,
+    int* der_key_len,
+    uint8_t* der_cert,
+    int* der_cert_len,
+    const struct ra_tls_options* opts
+)
+{
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_key = 1;
+        struct timeval listen_tv_start_key, listen_tv_end_key;
+        if( gettimeofday(&listen_tv_start_key, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_key = 0;
+        }
+#endif
+    /* Generate key. */
+    RSA* key;
+
+    static const int nr_bits = 2048;
+    key = RSA_generate_key(nr_bits, RSA_F4, NULL, NULL);
+    assert(NULL != key);
+    
+    uint8_t der[4096];
+    int derSz = i2d_RSAPrivateKey(key, NULL);
+    assert(derSz >= 0);
+    assert(derSz <= (int) *der_key_len);
+    unsigned char* p = der;
+    i2d_RSAPrivateKey(key, &p);
+
+    *der_key_len = derSz;
+    memcpy(der_key, der, derSz);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_key == 1 ) {
+            if ( gettimeofday(&listen_tv_end_key, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_key.tv_sec - listen_tv_start_key.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_key.tv_usec - listen_tv_start_key.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "RSA key\n");
+                //fflush(stdout);
+            }
+        }
+#endif
+
+    /* Generate certificate */
+    sgx_report_data_t report_data = {0, };
+    sha256_rsa_pubkey(report_data.d, key);
+    attestation_verification_report_t attestation_report;
+
+    do_remote_attestation(&report_data, opts, &attestation_report);
+
+    EVP_PKEY* evp_key = EVP_PKEY_new();
+    EVP_PKEY_assign_RSA(evp_key, key);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
+    generate_x509(evp_key, der_cert, der_cert_len,
+                  &attestation_report);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "x509\n");
+                //fflush(stdout);
+            }
+        }
+#endif
+    EVP_PKEY_free(evp_key);
+    evp_key = NULL;
+}
+
+void create_key_and_x509
+(
+    uint8_t* der_key,  /* out */
+    int* der_key_len,  /* in/out */
+    uint8_t* der_cert, /* out */
+    int* der_cert_len, /* in/out */
+    const struct ra_tls_options* opts /* in */
+)
+{
+    openssl_create_key_and_x509(der_key, der_key_len,
+                                der_cert, der_cert_len,
+                                opts);
+}
diff --git a/openssl-ra-challenger.c b/openssl-ra-challenger.c
index ef5ea24..38982b2 100644
--- a/openssl-ra-challenger.c
+++ b/openssl-ra-challenger.c
@@ -188,7 +188,7 @@ void get_quote_from_cert
     get_quote_from_report(ias_report, ias_report_len, q);
 }
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
@@ -220,6 +220,9 @@ void get_quote_from_report
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+
+    // TODO: return 1 on errors, remove asserts
+    return 0;
 }
 
 static
diff --git a/pull_request_438.patch b/pull_request_438.patch
new file mode 100644
index 0000000..ec3f49d
--- /dev/null
+++ b/pull_request_438.patch
@@ -0,0 +1,173 @@
+diff --git a/Pal/src/host/FreeBSD/db_events.c b/Pal/src/host/FreeBSD/db_events.c
+index cea539b..752d480 100644
+--- a/Pal/src/host/FreeBSD/db_events.c
++++ b/Pal/src/host/FreeBSD/db_events.c
+@@ -75,7 +75,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                              UMTX_OP_WAKE, 1, NULL, NULL);
+     }
+ 
+-    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+diff --git a/Pal/src/host/Linux-SGX/db_events.c b/Pal/src/host/Linux-SGX/db_events.c
+index 6e1548e..b8c29e3 100644
+--- a/Pal/src/host/Linux-SGX/db_events.c
++++ b/Pal/src/host/Linux-SGX/db_events.c
+@@ -25,6 +25,7 @@
+ 
+ #include "pal_defs.h"
+ #include "pal_linux_defs.h"
++#include "pal_linux_error.h"
+ #include "pal.h"
+ #include "pal_internal.h"
+ #include "pal_linux.h"
+@@ -67,7 +68,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                 ret = ocall_futex((int *) &event->event.signaled->counter,
+                                   FUTEX_WAKE, nwaiters, NULL);
+ 
+-                if (ret < 0)
++                if (IS_ERR(ret))
+                     atomic_set(event->event.signaled, 0);
+             }
+         }
+@@ -75,11 +76,9 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+         // Only one thread wakes up, leave unsignaled
+         ret = ocall_futex((int *) &event->event.signaled->counter,
+                           FUTEX_WAKE, 1, NULL);
+-        if (ret < 0)
+-             return ret;
+     }
+ 
+-    return ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+@@ -94,11 +93,13 @@ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+         do {
+             ret = ocall_futex((int *) &event->event.signaled->counter,
+                               FUTEX_WAIT, 0, timeout ? &waittime : NULL);
+-            if (ret < 0) {
+-                if (ret == -PAL_ERROR_TRYAGAIN)
++            if (IS_ERR(ret)) {
++                if (ERRNO(ret) == EWOULDBLOCK) {
+                     ret = 0;
+-                else
++                } else {
++                    ret = unix_to_pal_error(ERRNO(ret));
+                     break;
++                }
+             }
+         } while (event->event.isnotification &&
+                  !atomic_read(event->event.signaled));
+@@ -119,11 +120,13 @@ int _DkEventWait (PAL_HANDLE event)
+         do {
+             ret = ocall_futex((int *) &event->event.signaled->counter,
+                               FUTEX_WAIT, 0, NULL);
+-            if (ret < 0) {
+-                if (ret == -PAL_ERROR_TRYAGAIN)
++            if (IS_ERR(ret)) {
++                if (ERRNO(ret) == EWOULDBLOCK) {
+                     ret = 0;
+-                else
++                } else {
++                    ret = unix_to_pal_error(ERRNO(ret));
+                     break;
++                }
+             }
+         } while (event->event.isnotification &&
+                  !atomic_read(event->event.signaled));
+diff --git a/Pal/src/host/Linux-SGX/db_mutex.c b/Pal/src/host/Linux-SGX/db_mutex.c
+index f6c39c2..5cedac2 100644
+--- a/Pal/src/host/Linux-SGX/db_mutex.c
++++ b/Pal/src/host/Linux-SGX/db_mutex.c
+@@ -27,6 +27,7 @@
+ 
+ #include "pal_defs.h"
+ #include "pal_linux_defs.h"
++#include "pal_linux_error.h"
+ #include "pal.h"
+ #include "pal_internal.h"
+ #include "pal_linux.h"
+@@ -86,11 +87,13 @@ int _DkMutexLockTimeout (struct mutex_handle * m, uint64_t timeout)
+          */
+         ret = ocall_futex((int *) m->locked, FUTEX_WAIT, MUTEX_LOCKED, timeout == -1 ? NULL : &timeout);
+ 
+-        if (ret < 0) {
+-            if (-ret == EWOULDBLOCK) {
+-                ret = -PAL_ERROR_TRYAGAIN;
+-                atomic_dec(&m->nwaiters);
+-                goto out;
++        if (IS_ERR(ret)) {
++            if (ERRNO(ret) == EWOULDBLOCK) {
++                if (timeout != NO_TIMEOUT) {
++                    ret = -PAL_ERROR_TRYAGAIN;
++                    atomic_dec(&m->nwaiters);
++                    goto out;
++                }
+             }
+             ret = unix_to_pal_error(ERRNO(ret));
+             atomic_dec(&m->nwaiters);
+diff --git a/Pal/src/host/Linux-SGX/sgx_enclave.c b/Pal/src/host/Linux-SGX/sgx_enclave.c
+index f65cd86..ddc7373 100644
+--- a/Pal/src/host/Linux-SGX/sgx_enclave.c
++++ b/Pal/src/host/Linux-SGX/sgx_enclave.c
+@@ -239,6 +239,10 @@ static int sgx_ocall_create_process(void * pms)
+     return 0;
+ }
+ 
++/* sgx_ocall_futex return unix errno instead of PAL_ERROR
++ * because PAL_ERROR doesn't distinguish ETIMEDOUT and EAGAIN.
++ * In futex case, they needs to be distinguished.
++ */
+ static int sgx_ocall_futex(void * pms)
+ {
+     ms_ocall_futex_t * ms = (ms_ocall_futex_t *) pms;
+@@ -252,7 +256,7 @@ static int sgx_ocall_futex(void * pms)
+     }
+     ret = INLINE_SYSCALL(futex, 6, ms->ms_futex, ms->ms_op, ms->ms_val,
+                          ts, NULL, 0);
+-    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : ret;
++    return ret;
+ }
+ 
+ static int sgx_ocall_socketpair(void * pms)
+diff --git a/Pal/src/host/Linux/db_events.c b/Pal/src/host/Linux/db_events.c
+index 42d4bad..01a15f5 100644
+--- a/Pal/src/host/Linux/db_events.c
++++ b/Pal/src/host/Linux/db_events.c
+@@ -72,7 +72,7 @@ int _DkEventSet (PAL_HANDLE event, int wakeup)
+                              NULL, NULL, 0);
+     }
+ 
+-    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : ret;
++    return IS_ERR(ret) ? -PAL_ERROR_TRYAGAIN : ret;
+ }
+ 
+ int _DkEventWaitTimeout (PAL_HANDLE event, uint64_t timeout)
+diff --git a/Pal/src/host/Linux/db_mutex.c b/Pal/src/host/Linux/db_mutex.c
+index 4e9e55e..8b0a7ac 100644
+--- a/Pal/src/host/Linux/db_mutex.c
++++ b/Pal/src/host/Linux/db_mutex.c
+@@ -130,14 +130,13 @@ int _DkMutexLockTimeout (struct mutex_handle * m, uint64_t timeout)
+                     atomic_dec(&m->nwaiters);
+                     goto out;
+                 }
+-            } else {
++            }
+ #ifdef DEBUG_MUTEX
+-                printf("futex failed (err = %d)\n", ERRNO(ret));
++            printf("futex failed (err = %d)\n", ERRNO(ret));
+ #endif
+-                ret = unix_to_pal_error(ERRNO(ret));
+-                atomic_dec(&m->nwaiters);
+-                goto out;
+-            }
++            ret = unix_to_pal_error(ERRNO(ret));
++            atomic_dec(&m->nwaiters);
++            goto out;
+         }
+     }
+ 
diff --git a/ra-challenger.c b/ra-challenger.c
index d2d1fc1..9f3b56c 100644
--- a/ra-challenger.c
+++ b/ra-challenger.c
@@ -24,7 +24,7 @@ const uint8_t ias_report_signature_oid[] = OID(0x05);
 
 const size_t ias_oid_len = sizeof(ias_response_body_oid);
 
-void find_oid
+int find_oid
 (
      const unsigned char* ext, size_t ext_len,
      const unsigned char* oid, size_t oid_len,
@@ -32,7 +32,12 @@ void find_oid
 )
 {
     uint8_t* p = memmem(ext, ext_len, oid, oid_len);
-    assert(p != NULL);
+    
+    // if not found, failure
+    if (p == NULL) {
+        return 1;
+    }
+    //assert(p != NULL);
 
     p += oid_len;
 
@@ -42,15 +47,23 @@ void find_oid
     // Enable again if extension is deemed critical. Most TLS
     // implementation will fail validation of a certificate with
     // unknown critical extensions.
-    assert(p[i++] == 0x01);
-    assert(p[i++] == 0x01);
-    assert(p[i++] == 0xFF);
+    if(p[i++] != 0x01 ||
+       p[i++] == 0x01 ||
+       p[i++] == 0xFF) {
+        return 1;
+    }
 #endif
 
     // Now comes the octet string
-    assert(p[i++] == 0x04); // tag for octet string
-    assert(p[i++] == 0x82); // length encoded in two bytes
+    // tag for octet string
+    if(p[i++] != 0x04 ||
+       // length encoded in two bytes
+       p[i++] != 0x82) {
+        return 1;
+    }
     *len  =  p[i++] << 8;
     *len +=  p[i++];
     *val  = &p[i++];
+    
+    return 0;
 }
diff --git a/ra-challenger.h b/ra-challenger.h
index d7647bc..3c8032c 100644
--- a/ra-challenger.h
+++ b/ra-challenger.h
@@ -3,7 +3,7 @@
 
 #include <sgx_quote.h>
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
diff --git a/ra-challenger_private.h b/ra-challenger_private.h
index 3b0c493..512b1c0 100644
--- a/ra-challenger_private.h
+++ b/ra-challenger_private.h
@@ -8,7 +8,7 @@ extern const uint8_t ias_report_signature_oid[];
 
 extern const size_t ias_oid_len;
 
-void find_oid
+int find_oid
 (
      const unsigned char* ext, size_t ext_len,
      const unsigned char* oid, size_t oid_len,
diff --git a/ra_tls_options.c b/ra_tls_options.c
index 3c84a5f..04198ea 100644
--- a/ra_tls_options.c
+++ b/ra_tls_options.c
@@ -5,8 +5,9 @@ struct ra_tls_options my_ra_tls_options = {
               0x00, 0x00, 0x00, 0x00,
               0x00, 0x00, 0x00, 0x00,
               0x00, 0x00, 0x00, 0x00}},
-    .quote_type = SGX_UNLINKABLE_SIGNATURE,
-    .ias_key_file = "./ias-client-key.pem",
-    .ias_cert_file = "./ias-client-cert.pem",
-    .ias_server = "test-as.sgx.trustedservices.intel.com:443"
+    .quote_type = SGX_LINKABLE_SIGNATURE,
+//    .ias_key_file = "./ias-client-key.pem",
+//    .ias_cert_file = "./ias-client-cert.pem",
+//    .ias_server = "test-as.sgx.trustedservices.intel.com:443"
+    .ias_server = "api.trustedservices.intel.com:443"
 };
diff --git a/ssl-client.manifest b/ssl-client.manifest
new file mode 100644
index 0000000..474815e
--- /dev/null
+++ b/ssl-client.manifest
@@ -0,0 +1,120 @@
+loader.preload = file:deps/graphene/Runtime/libsysdb.so
+loader.env.LD_LIBRARY_PATH = /lib
+#loader.debug_type = inline
+loader.debug_type = none
+loader.syscall_symbol = syscalldb
+#loader.env.LD_PRELOAD = deps/graphene/Runtime/libtri_lib.so
+#loader.env.LD_PRELOAD = deps/graphene/Runtime/libtest_lib.so
+loader.env.LD_PRELOAD = deps/graphene/Runtime/libpreload_hooker.so
+
+fs.mount.lib.type = chroot
+fs.mount.lib.path = /lib
+fs.mount.lib.uri = file:deps/graphene/Runtime
+
+fs.mount.bin.type = chroot
+fs.mount.bin.path = /bin
+fs.mount.bin.uri = file:/bin
+
+sgx.enclave_size = 1024M
+sys.brk.size = 32M
+sys.stack.size = 4M
+
+# allow to bind on port 8000
+#net.allow_bind.1 = 127.0.0.1:8000
+# allow to connect to port 8000
+net.allow_peer.1 = 111.222.111.222:12345
+net.allow.peer.2 = 34.234.230.147:443
+
+#net.allow_bind.https = 127.0.0.1:4433
+#net.allow_peer.https = 127.0.0.1:4433
+
+# sgx-related
+sgx.trusted_files.libscnd = file:deps/graphene/Runtime/libscnd_lib.so
+sgx.trusted_files.libtest = file:deps/graphene/Runtime/libtest_lib.so
+sgx.trusted_files.libtri = file:deps/graphene/Runtime/libtri_lib.so
+
+sgx.trusted_files.libpreloadhook = file:deps/graphene/Runtime/libpreload_hooker.so
+
+sgx.trusted_files.libclientpac = file:deps/graphene/Runtime/libclient_pac.so
+sgx.trusted_files.libcommonenc = file:deps/graphene/Runtime/libcommon_enc.so
+sgx.trusted_files.libratlscli = file:deps/graphene/Runtime/libratls_client.so
+
+sgx.trusted_files.ld = file:deps/graphene/Runtime/ld-linux-x86-64.so.2
+sgx.trusted_files.libdl = file:deps/graphene/Runtime/libdl.so.2
+sgx.trusted_files.libpthread = file:deps/graphene/Runtime/libpthread.so.0
+sgx.trusted_files.libc = file:deps/graphene/Runtime/libc.so.6
+sgx.trusted_files.libm = file:deps/graphene/Runtime/libm.so.6
+
+sgx.trusted_files.libprotobufc = file:deps/graphene/Runtime/libprotobuf-c.so.1
+sgx.trusted_files.libresolv = file:deps/graphene/Runtime/libresolv.so.2
+sgx.trusted_files.libnssdnsso2 = file:deps/graphene/Runtime/libnss_dns.so.2
+
+sgx.trusted_files.libsgx_uae_service = file:deps/graphene/Runtime/libsgx_uae_service.so
+
+sgx.trusted_files.libcrypto = file:deps/graphene/Runtime/libcrypto.so.1.0.0
+sgx.trusted_files.libz = file:deps/graphene/Runtime/libz.so.1
+sgx.trusted_files.libssl = file:deps/graphene/Runtime/libssl.so.1.0.0
+
+# might in future want to use local version instead for compilation and then
+# create the symlink based on the local library version not the system-wide one
+#sgx.trusted_files.libcurl = file:/deps/local/lib/libcurl.4.so
+
+# via ./copy_libs_helper.bash
+# BUG Graphene cannot handle '-' character in trusted_files name (also of coure no '.')
+
+sgx.trusted_files.libcomerr = file:deps/graphene/Runtime/libcom_err.so.2
+sgx.trusted_files.libcrypt = file:deps/graphene/Runtime/libcrypt.so.1
+sgx.trusted_files.libkeyutils = file:deps/graphene/Runtime/libkeyutils.so.1
+sgx.trusted_files.libasn1 = file:deps/graphene/Runtime/libasn1.so.8
+sgx.trusted_files.libcurl = file:deps/graphene/Runtime/libcurl.so.4
+sgx.trusted_files.libffi = file:deps/graphene/Runtime/libffi.so.6
+sgx.trusted_files.libgmp = file:deps/graphene/Runtime/libgmp.so.10
+sgx.trusted_files.libgnutls = file:deps/graphene/Runtime/libgnutls.so.30
+sgx.trusted_files.libgssapi = file:deps/graphene/Runtime/libgssapi.so.3
+sgx.trusted_files.libgssapikrb5 = file:deps/graphene/Runtime/libgssapi_krb5.so.2
+sgx.trusted_files.libhcrypto = file:deps/graphene/Runtime/libhcrypto.so.4
+sgx.trusted_files.libheimbase = file:deps/graphene/Runtime/libheimbase.so.1
+sgx.trusted_files.libheimntlm = file:deps/graphene/Runtime/libheimntlm.so.0
+sgx.trusted_files.libhogweed = file:deps/graphene/Runtime/libhogweed.so.4
+sgx.trusted_files.libhx509 = file:deps/graphene/Runtime/libhx509.so.5
+sgx.trusted_files.libidn = file:deps/graphene/Runtime/libidn.so.11
+sgx.trusted_files.libk5crypto = file:deps/graphene/Runtime/libk5crypto.so.3
+sgx.trusted_files.libkrb526 = file:deps/graphene/Runtime/libkrb5.so.26
+sgx.trusted_files.libkrb53 = file:deps/graphene/Runtime/libkrb5.so.3
+sgx.trusted_files.libkrb5support = file:deps/graphene/Runtime/libkrb5support.so.0
+sgx.trusted_files.liblber24 = file:deps/graphene/Runtime/liblber-2.4.so.2
+sgx.trusted_files.libldapr24 = file:deps/graphene/Runtime/libldap_r-2.4.so.2
+sgx.trusted_files.libnettle = file:deps/graphene/Runtime/libnettle.so.6
+sgx.trusted_files.libp11kit = file:deps/graphene/Runtime/libp11-kit.so.0
+sgx.trusted_files.libroken = file:deps/graphene/Runtime/libroken.so.18
+sgx.trusted_files.librtmp = file:deps/graphene/Runtime/librtmp.so.1
+sgx.trusted_files.libsasl2 = file:deps/graphene/Runtime/libsasl2.so.2
+sgx.trusted_files.libsqlite3 = file:deps/graphene/Runtime/libsqlite3.so.0
+sgx.trusted_files.libtasn1 = file:deps/graphene/Runtime/libtasn1.so.6
+sgx.trusted_files.libwind = file:deps/graphene/Runtime/libwind.so.0
+
+#new
+sgx.trusted_files.libcxx = file:deps/graphene/Runtime/libstdc++.so.6
+sgx.trusted_files.libgcc = file:deps/graphene/Runtime/libgcc_s.so.1
+
+#newer
+sgx.trusted_files.libprotobufcpp = file:deps/graphene/Runtime/libprotobuf.so.9
+
+#experimental + ultra new
+sgx.trusted_files.libuv = file:deps/graphene/Runtime/libuv.so.1
+sgx.trusted_files.librt = file:deps/graphene/Runtime/librt.so.1
+
+# now also boost as long as new C++ standard with shared_mutex is missing in enclave/docker ...
+sgx.trusted_files.boostthread = file:deps/graphene/Runtime/libboost_thread.so.1.58.0
+sgx.trusted_files.boostsystem = file:deps/graphene/Runtime/libboost_system.so.1.58.0
+
+fs.mount.etc.type = chroot
+fs.mount.etc.path = /etc
+fs.mount.etc.uri = file:/etc
+
+sgx.trusted_files.cacertificates = file:/etc/ssl/certs/ca-certificates.crt
+
+sgx.trusted_files.client_ias_key = file:ias-client-key.pem
+sgx.trusted_files.client_ias_cert = file:ias-client-cert.pem
+
+sgx.trusted_files.etcresolv = file:/etc/resolv.conf
diff --git a/try_again.bash b/try_again.bash
new file mode 100644
index 0000000..03f2293
--- /dev/null
+++ b/try_again.bash
@@ -0,0 +1,14 @@
+#!/bin/bash
+cd ~/sgx-ra-tls/
+SGX_MODE=HW make mbedtls/libnonsdk-ra-attester.a || exit 1
+
+cd ~/client_enclave/demo_mbedtls_client/build/
+SGX_MODE=HW make ssl_client || exit 1
+cp ./src/ssl_client ~/sgx-ra-tls
+
+cd ~/sgx-ra-tls/
+deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output ssl_client.manifest.sgx -exec ssl_client -manifest ssl-client.manifest ; deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output ssl_client.token -sig ssl_client.sig
+
+#su -c "SGX=1 ./deps/graphene/Runtime/pal_loader ./ssl_client" root
+export SGX=1
+sudo -E ./deps/graphene/Runtime/pal_loader ./ssl_client
diff --git a/wolfssl-ra-challenger.c b/wolfssl-ra-challenger.c
index cfc6068..8c50c1d 100644
--- a/wolfssl-ra-challenger.c
+++ b/wolfssl-ra-challenger.c
@@ -116,7 +116,7 @@ void get_quote_from_cert
     FreeDecodedCert(&crt);
 }
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
@@ -147,6 +147,9 @@ void get_quote_from_report
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+
+    // TODO: return 1 on errors, remove asserts
+    return 0;
 }
 
 static
